# Skill: Notify Team via Slack
# Send notifications to Slack channels

name: notify_team
description: |
  Send notifications to Slack channels for key workflow events.
  Uses consistent templates for uniform, predictable messages.

  ## Templates Available

  **mr_ready** - MR ready for review
  ```json
  {"template": "mr_ready", "template_data": {"mr_id": "1495", "title": "fix(deps): update urllib3", "url": "https://gitlab.../1495", "issue_key": "AAP-62128"}}
  ```

  **deployment** - Deployment status
  ```json
  {"template": "deployment", "template_data": {"environment": "stage", "namespace": "ephemeral-xxx", "status": "success", "duration": "5m"}}
  ```

  **alert** - Alert notification
  ```json
  {"template": "alert", "template_data": {"alert_name": "HighCPU", "severity": "warning", "environment": "prod"}}
  ```

  **release** - Release announcement
  ```json
  {"template": "release", "template_data": {"version": "1.2.3", "environments": ["stage", "prod"]}}
  ```

  **cve_fix** - Security fix notification
  ```json
  {"template": "cve_fix", "template_data": {"cve_id": "CVE-2025-66471", "package": "urllib3", "version": "2.6.3", "mr_url": "https://...", "issue_key": "AAP-12345"}}
  ```

  **generic** - Plain message with emoji (default)

  ## Quick Examples

  Simple message:
  ```
  skill_run("notify_team", '{"message": "Build complete"}')
  ```

  MR notification:
  ```
  skill_run("notify_team", '{"message": "", "template": "mr_ready", "template_data": {"mr_id": "1495", "title": "fix: update deps", "url": "https://...", "issue_key": "AAP-62128"}}')
  ```

version: "1.1"

links:
  depends_on: []            # Standalone notification utility
  validates: []             # Notification doesn't validate other skills
  validated_by: []          # Terminal communication action
  chains_to: []             # No natural next step after notification
  provides_context_for:
    - standup_summary       # Sent notifications appear in standup context
    - weekly_summary        # Notification activity for weekly report

inputs:
  - name: message
    type: string
    required: true
    description: "Message to send"

  - name: channel
    type: string
    required: false
    default: ""
    description: "Slack channel name or ID (defaults to team channel from config.json)"

  - name: type
    type: string
    required: false
    default: "info"
    description: "Message type: 'info', 'success', 'warning', 'error', 'deployment', 'release'"

  - name: mention
    type: string
    required: false
    description: "User to mention (Slack username or email)"

  - name: thread_ts
    type: string
    required: false
    description: "Thread timestamp to reply to (for threaded messages)"

  - name: context
    type: string
    required: false
    description: "Additional context (e.g., MR ID, namespace, issue key)"

  - name: template
    type: string
    required: false
    default: ""
    description: |
      Message template to use. If not specified, auto-detects from 'type'.
      Available templates:
        - mr_ready: MR ready for review (requires: mr_id, title, url, issue_key)
        - mr_merged: MR merged notification (requires: mr_id, title, url)
        - deployment: Deployment status (requires: environment, namespace, status)
        - alert: Alert notification (requires: alert_name, severity, environment)
        - release: Release announcement (requires: version, environments)
        - cve_fix: CVE fix notification (requires: cve_id, package, version, mr_url, issue_key)
        - generic: Plain message with emoji (default)

  - name: template_data
    type: object
    required: false
    description: |
      Data for the template as JSON object. Fields depend on template:
        mr_ready: {"mr_id": "1495", "title": "fix: ...", "url": "https://...", "issue_key": "AAP-12345"}
        deployment: {"environment": "stage", "namespace": "ephemeral-xxx", "status": "success", "duration": "5m"}
        alert: {"alert_name": "HighCPU", "severity": "warning", "environment": "prod", "runbook": "https://..."}
        release: {"version": "1.2.3", "environments": ["stage", "prod"], "changelog": "..."}
        cve_fix: {"cve_id": "CVE-2025-66471", "package": "urllib3", "version": "2.6.3", "mr_url": "https://...", "issue_key": "AAP-12345"}

steps:
  # ==================== LOAD SLACK PERSONA ====================
  # This skill requires slack tools which are only in slack/admin personas

  - name: load_slack_persona
    description: "Load slack persona for Slack notification tools"
    tool: persona_load
    args:
      persona_name: "slack"

  # ==================== PROACTIVE ISSUE DETECTION ====================

  - name: check_slack_known_issues
    description: "Check for known Slack issues before starting"
    tool: check_known_issues
    args:
      tool_name: "slack_send_message"
      error_text: ""
    output: slack_known_issues
    on_error: continue

  - name: init_autoheal
    description: "Initialize failure tracking"
    compute: |
      result = {"slack_failures": []}
    output: autoheal_state
    on_error: continue

  # ==================== LOAD CONFIG ====================

  - name: load_slack_config
    description: "Load Slack configuration from config.json"
    compute: |
      from scripts.common.config_loader import load_config

      config = load_config()
      slack_cfg = config.get("slack", {})
      channels_cfg = slack_cfg.get("channels", {})

      # Get team channel from config
      team_channel = channels_cfg.get("team", {})
      team_channel_id = team_channel.get("id", "")
      team_channel_name = team_channel.get("name", "")

      # Use input channel if provided, otherwise default to team channel from config
      channel_input = inputs.get("channel") if hasattr(inputs, 'get') else getattr(inputs, 'channel', None)
      if channel_input and channel_input.strip():
          resolved_channel = channel_input.strip()
      else:
          # Default to team channel ID from config
          resolved_channel = team_channel_id or team_channel_name or "team-automation-analytics"

      result = {
          "team_channel_id": team_channel_id,
          "team_channel_name": team_channel_name,
          "resolved_channel": resolved_channel,
          "group_handle": team_channel.get("group_handle", ""),
      }
    output: channel_config

  # ==================== FIND CHANNEL ====================

  - name: list_channels
    description: "List available Slack channels"
    tool: slack_list_channels
    args:
      limit: 100
    output: channels_raw
    on_error: auto_heal  # Slack API - may need auth

  - name: find_channel
    description: "Find the target channel"
    compute: |
      channels_text = str(channels_raw) if channels_raw else ""
      import re

      # Use resolved channel from config (already handles default to team channel)
      original_channel = channel_config.get("resolved_channel", "").replace("#", "")

      # Check if input is already a channel ID (starts with C and is alphanumeric)
      is_channel_id = bool(re.match(r'^C[A-Z0-9]+$', original_channel))

      if is_channel_id:
          # Input is already a channel ID, use it directly
          channel_id = original_channel
          channel_found = True
          # Try to get friendly name from config
          channel_name = channel_config.get("team_channel_name") if original_channel == channel_config.get("team_channel_id") else original_channel
      else:
          # Input is a channel name, search for it
          target = original_channel.lower()
          channel_found = target in channels_text.lower()

          # Try to extract channel ID from listing
          channel_id = None
          for line in channels_text.split("\n"):
              if target in line.lower():
                  # Look for channel ID pattern
                  id_match = re.search(r'(C[A-Z0-9]+)', line)
                  if id_match:
                      channel_id = id_match.group(1)
                      break
          channel_name = target

      result = {
          "found": channel_found,
          "channel_id": channel_id,
          "channel_name": channel_name,
      }
    output: channel_info

  # ==================== RESOLVE USER ====================

  - name: get_user_info
    description: "Get Slack user info for mentions"
    condition: "inputs.mention"
    tool: slack_get_user
    args:
      user: "{{ inputs.mention }}"
    output: user_info_raw
    on_error: continue

  - name: parse_user
    description: "Parse user info for mention"
    condition: "inputs.mention"
    compute: |
      user_text = str(user_info_raw) if 'user_info_raw' in dir() and user_info_raw else ""

      # Extract user ID for mention
      import re
      user_id = None
      id_match = re.search(r'(U[A-Z0-9]+)', user_text)
      if id_match:
          user_id = id_match.group(1)

      result = {
          "user_id": user_id,
          "mention_text": f"<@{user_id}>" if user_id else inputs.mention,
      }
    output: user_mention
    on_error: continue

  # ==================== FORMAT MESSAGE ====================

  - name: format_message
    description: "Format the Slack message using templates for consistent notifications"
    compute: |
      import json

      msg_type = inputs.get("type", "info").lower() if hasattr(inputs, 'get') else getattr(inputs, 'type', 'info').lower()
      template_name = inputs.get("template", "").lower() if hasattr(inputs, 'get') else getattr(inputs, 'template', '').lower()
      message = inputs.get("message", "") if hasattr(inputs, 'get') else getattr(inputs, 'message', '')

      # Parse template_data if provided
      template_data_raw = inputs.get("template_data") if hasattr(inputs, 'get') else getattr(inputs, 'template_data', None)
      if isinstance(template_data_raw, str):
          try:
              data = json.loads(template_data_raw)
          except Exception:
              data = {}
      elif isinstance(template_data_raw, dict):
          data = template_data_raw
      else:
          data = {}

      # Auto-detect template from type if not specified
      if not template_name:
          type_to_template = {
              "mr_ready": "mr_ready",
              "mr_merged": "mr_merged",
              "deployment": "deployment",
              "alert": "alert",
              "release": "release",
              "cve": "cve_fix",
          }
          template_name = type_to_template.get(msg_type, "generic")

      # Emoji map
      emoji_map = {
          "info": "â„¹ï¸",
          "success": "âœ…",
          "warning": "âš ï¸",
          "error": "âŒ",
          "deployment": "ğŸš€",
          "release": "ğŸ“¦",
          "mr_ready": "ğŸ”",
          "mr_merged": "âœ…",
          "alert": "ğŸš¨",
          "cve": "ğŸ”’",
      }
      emoji = emoji_map.get(msg_type, emoji_map.get(template_name, "ğŸ“¢"))

      # ==================== TEMPLATES ====================

      def format_mr_ready(data, message):
          """MR ready for review template"""
          mr_id = data.get("mr_id", "")
          title = data.get("title", message)
          url = data.get("url", "")
          issue_key = data.get("issue_key", "")
          author = data.get("author", "")

          lines = ["ğŸ” *MR Ready for Review*"]
          lines.append("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")

          if mr_id:
              if url:
                  lines.append(f"*MR:* <{url}|!{mr_id}>")
              else:
                  lines.append(f"*MR:* !{mr_id}")

          if title:
              lines.append(f"*Title:* {title}")

          if issue_key:
              jira_url = f"https://issues.redhat.com/browse/{issue_key}"
              lines.append(f"*Jira:* <{jira_url}|{issue_key}>")

          if author:
              lines.append(f"*Author:* {author}")

          return "\n".join(lines)

      def format_mr_merged(data, message):
          """MR merged template"""
          mr_id = data.get("mr_id", "")
          title = data.get("title", message)
          url = data.get("url", "")
          target_branch = data.get("target_branch", "main")

          lines = ["âœ… *MR Merged*"]
          lines.append("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")

          if mr_id:
              if url:
                  lines.append(f"*MR:* <{url}|!{mr_id}>")
              else:
                  lines.append(f"*MR:* !{mr_id}")

          if title:
              lines.append(f"*Title:* {title}")

          lines.append(f"*Branch:* `{target_branch}`")

          return "\n".join(lines)

      def format_deployment(data, message):
          """Deployment notification template"""
          environment = data.get("environment", "unknown")
          namespace = data.get("namespace", "")
          status = data.get("status", "unknown")
          duration = data.get("duration", "")
          image = data.get("image", "")
          sha = data.get("sha", "")

          status_emoji = "âœ…" if status.lower() in ("success", "complete", "ready") else "âŒ" if status.lower() in ("failed", "error") else "ğŸ”„"

          lines = [f"ğŸš€ *Deployment {status.title()}*"]
          lines.append("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
          lines.append(f"*Environment:* `{environment}`")

          if namespace:
              lines.append(f"*Namespace:* `{namespace}`")

          lines.append(f"*Status:* {status_emoji} {status}")

          if duration:
              lines.append(f"*Duration:* {duration}")

          if sha:
              lines.append(f"*Commit:* `{sha[:12]}`")

          if image:
              lines.append(f"*Image:* `{image}`")

          if message and message != status:
              lines.append(f"\n{message}")

          return "\n".join(lines)

      def format_alert(data, message):
          """Alert notification template"""
          alert_name = data.get("alert_name", message)
          severity = data.get("severity", "warning")
          environment = data.get("environment", "")
          runbook = data.get("runbook", "")
          description = data.get("description", "")

          severity_emoji = {"critical": "ğŸ”´", "warning": "ğŸŸ¡", "info": "ğŸ”µ"}.get(severity.lower(), "ğŸŸ¡")

          lines = [f"ğŸš¨ *Alert: {alert_name}*"]
          lines.append("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
          lines.append(f"*Severity:* {severity_emoji} {severity.upper()}")

          if environment:
              lines.append(f"*Environment:* `{environment}`")

          if description:
              lines.append(f"*Details:* {description}")

          if runbook:
              lines.append(f"*Runbook:* <{runbook}|View Runbook>")

          return "\n".join(lines)

      def format_release(data, message):
          """Release announcement template"""
          version = data.get("version", "")
          environments = data.get("environments", [])
          changelog = data.get("changelog", "")
          release_url = data.get("release_url", "")

          lines = ["ğŸ“¦ *New Release*"]
          lines.append("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")

          if version:
              if release_url:
                  lines.append(f"*Version:* <{release_url}|{version}>")
              else:
                  lines.append(f"*Version:* `{version}`")

          if environments:
              env_list = ", ".join(f"`{e}`" for e in environments)
              lines.append(f"*Environments:* {env_list}")

          if changelog:
              lines.append(f"\n*Changes:*\n{changelog}")

          if message and message != version:
              lines.append(f"\n{message}")

          return "\n".join(lines)

      def format_cve_fix(data, message):
          """CVE fix notification template"""
          cve_id = data.get("cve_id", "")
          package = data.get("package", "")
          version = data.get("version", "")
          mr_url = data.get("mr_url", "")
          mr_id = data.get("mr_id", "")
          severity = data.get("severity", "")
          issue_key = data.get("issue_key", "")

          lines = ["ğŸ”’ *Security Fix*"]
          lines.append("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")

          if cve_id:
              cve_url = f"https://nvd.nist.gov/vuln/detail/{cve_id}"
              lines.append(f"*CVE:* <{cve_url}|{cve_id}>")

          if severity:
              severity_emoji = {"critical": "ğŸ”´", "high": "ğŸŸ ", "medium": "ğŸŸ¡", "low": "ğŸŸ¢"}.get(severity.lower(), "")
              lines.append(f"*Severity:* {severity_emoji} {severity.upper()}")

          if package and version:
              lines.append(f"*Fix:* `{package}` â†’ `{version}`")
          elif package:
              lines.append(f"*Package:* `{package}`")

          if issue_key:
              jira_url = f"https://issues.redhat.com/browse/{issue_key}"
              lines.append(f"*Issue:* <{jira_url}|{issue_key}>")

          if mr_url:
              mr_label = f"!{mr_id}" if mr_id else "View MR"
              lines.append(f"*MR:* <{mr_url}|{mr_label}> ({mr_url})")

          if message:
              lines.append(f"\n{message}")

          return "\n".join(lines)

      def format_generic(data, message, emoji):
          """Generic message with emoji"""
          parts = [f"{emoji} {message}"]

          # Add any extra data fields
          for key, value in data.items():
              if key not in ("message",) and value:
                  parts.append(f"*{key.replace('_', ' ').title()}:* {value}")

          return "\n".join(parts)

      # ==================== SELECT TEMPLATE ====================

      template_funcs = {
          "mr_ready": format_mr_ready,
          "mr_merged": format_mr_merged,
          "deployment": format_deployment,
          "alert": format_alert,
          "release": format_release,
          "cve_fix": format_cve_fix,
      }

      if template_name in template_funcs:
          formatted = template_funcs[template_name](data, message)
      else:
          formatted = format_generic(data, message, emoji)

      # Add mention if provided
      if 'user_mention' in dir() and user_mention and user_mention.get('mention_text'):
          formatted += f"\n\ncc: {user_mention['mention_text']}"

      # Add context if provided
      context_val = inputs.get("context") if hasattr(inputs, 'get') else getattr(inputs, 'context', None)
      if context_val:
          formatted += f"\n```{context_val}```"

      result = {
          "text": formatted,
          "emoji": emoji,
          "template": template_name,
      }
    output: formatted_msg

  # ==================== SEND MESSAGE ====================

  - name: post_message
    description: "Post the message to Slack"
    tool: slack_send_message
    args:
      target: "{{ channel_info.channel_id or channel_info.channel_name }}"
      text: "{{ formatted_msg.text }}"
      thread_ts: "{{ inputs.thread_ts | default('', true) }}"
    output: post_result
    on_error: auto_heal  # Slack API - may need auth

  - name: parse_post_result
    description: "Parse post result"
    compute: |
      result_text = str(post_result) if post_result else ""

      success = "error" not in result_text.lower() and "failed" not in result_text.lower()

      # Extract message timestamp for threading
      import re
      ts = None
      ts_match = re.search(r'(\d+\.\d+)', result_text)
      if ts_match:
          ts = ts_match.group(1)

      result = {
          "success": success,
          "thread_ts": ts,
          "raw": result_text[:300] if result_text else "No response",
      }
    output: post_status

  # ==================== MEMORY ====================

  - name: log_notification
    description: "Log notification to session"
    condition: "post_status.success"
    tool: memory_session_log
    args:
      action: "Sent Slack notification"
      details: "Channel: #{{ channel_info.channel_name }}, Type: {{ inputs.type }}"
    on_error: continue

  - name: track_notifications
    description: "Track notifications for patterns"
    condition: "post_status.success"
    compute: |
      from datetime import datetime

      # Load patterns
      patterns = memory.read_memory("learned/patterns") or {}
      if "slack_notifications" not in patterns:
          patterns["slack_notifications"] = []

      # Record this notification (use .get() for dict access)
      channel_name = channel_info.get("channel_name", "unknown") if isinstance(channel_info, dict) else "unknown"
      msg_type = inputs.get("type", "info") if hasattr(inputs, 'get') else getattr(inputs, 'type', 'info')
      has_mention = bool(inputs.get("mention") if hasattr(inputs, 'get') else getattr(inputs, 'mention', None))
      has_context = bool(inputs.get("context") if hasattr(inputs, 'get') else getattr(inputs, 'context', None))
      has_thread = bool(inputs.get("thread_ts") if hasattr(inputs, 'get') else getattr(inputs, 'thread_ts', None))

      notification_record = {
          "channel": channel_name,
          "type": msg_type,
          "has_mention": has_mention,
          "has_context": has_context,
          "threaded": has_thread,
          "timestamp": datetime.now().isoformat(),
      }

      patterns["slack_notifications"].append(notification_record)

      # Keep last 100 notifications
      patterns["slack_notifications"] = patterns["slack_notifications"][-100:]

      memory.write_memory("learned/patterns", patterns)
      result = "notification tracked"
    output: notification_tracking_result
    on_error: continue

  # ==================== LEARNING FROM FAILURES ====================

  - name: detect_notify_team_failures
    description: "Detect failure patterns from team notification"
    compute: |
      errors_detected = []

      # Check Slack failures
      post_text = str(post_result_raw) if 'post_result_raw' in dir() and post_result_raw else ""
      channel_text = str(channel_info) if 'channel_info' in dir() and channel_info else ""
      combined = post_text + channel_text

      if "not_in_channel" in combined.lower() or "channel_not_found" in combined.lower():
          errors_detected.append({
              "tool": "slack_send_message",
              "pattern": "channel_not_found",
              "cause": "Slack channel not found or bot not added",
              "fix": "Check channel name and invite bot to channel"
          })
      if "invalid_auth" in combined.lower():
          errors_detected.append({
              "tool": "slack_send_message",
              "pattern": "invalid_auth",
              "cause": "Slack token expired or invalid",
              "fix": "Check Slack token in config.json"
          })
      if "rate_limited" in combined.lower():
          errors_detected.append({
              "tool": "slack_send_message",
              "pattern": "rate_limited",
              "cause": "Slack API rate limit exceeded",
              "fix": "Wait a few seconds and retry"
          })

      result = errors_detected
    output: notify_team_errors_detected
    on_error: continue

  - name: learn_notify_team_channel_failure
    description: "Learn from channel not found failures"
    condition: "notify_team_errors_detected and any(e.get('pattern') == 'channel_not_found' for e in notify_team_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "slack_send_message"
      error_pattern: "channel_not_found"
      root_cause: "Slack channel not found or bot not added"
      fix_description: "Check channel name and invite bot to channel"
    output: notify_team_channel_fix_learned
    on_error: continue

outputs:
  - name: report
    value: |
      ## ğŸ’¬ Slack Notification

      {% if post_status.success %}
      âœ… **Message Sent**

      **Channel:** #{{ channel_info.channel_name }}
      **Type:** {{ formatted_msg.emoji }} {{ inputs.type }}

      {% if post_status.thread_ts %}
      **Thread ID:** `{{ post_status.thread_ts }}`

      To reply in thread:
      ```python
      skill_run("notify_team", '{"message": "Follow-up", "channel": "{{ channel_info.channel_name }}", "thread_ts": "{{ post_status.thread_ts }}"}')
      ```
      {% endif %}

      {% else %}
      âŒ **Failed to Send**

      {{ post_status.raw }}

      {% if not channel_info.found %}
      âš ï¸ Channel `#{{ inputs.channel }}` not found.

      Available channels:
      ```python
      slack_list_channels(limit=50)
      ```
      {% endif %}
      {% endif %}

  - name: context
    value:
      sent: "{{ post_status.success }}"
      channel: "{{ channel_info.channel_name }}"
      thread_ts: "{{ post_status.thread_ts }}"
