# =============================================================================
# SLACK AGENT CONFIRM - Handle Confirmed Actions
# =============================================================================
# Processes confirmation responses from users and executes the confirmed action.
# This is called when a user responds "yes" to a proposed action.
#
# Usage:
#   skill_run("slack_agent_confirm", '{"action": "start_work", "issue_key": "AAP-12345"}')
#   skill_run("slack_agent_confirm", '{"action": "debug_prod", "namespace": "tower-analytics-prod"}')
# =============================================================================

name: slack_agent_confirm
description: |
  Handles confirmed actions from Slack agent interactions.
  Executes the confirmed skill and reports results back to Slack.

version: "1.0.0"

inputs:
  - name: action
    type: string
    required: true
    description: "Action to execute (start_work, debug_prod, review_pr, etc.)"

  - name: message_id
    type: string
    required: false
    default: ""
    description: "Original message ID for threading"

  - name: channel_id
    type: string
    required: false
    default: ""
    description: "Channel to respond in"

  - name: thread_ts
    type: string
    required: false
    default: ""
    description: "Thread to respond in"

  # Action-specific inputs
  - name: issue_key
    type: string
    required: false
    default: ""
    description: "Jira issue key (for start_work, close_issue, etc.)"

  - name: mr_id
    type: string
    required: false
    default: ""
    description: "MR ID (for review_pr, rebase_pr, etc.)"

  - name: namespace
    type: string
    required: false
    default: ""
    description: "Kubernetes namespace (for debug_prod)"

  - name: repo
    type: string
    required: false
    default: "."
    description: "Repository path"

steps:
  # ==================== VALIDATE INPUT ====================

  - name: validate_action
    description: "Validate the requested action"
    compute: |
      valid_actions = [
          "start_work",
          "close_issue",
          "review_pr",
          "rebase_pr",
          "sync_branch",
          "create_mr",
          "debug_prod",
          "jira_hygiene",
          "standup_summary",
      ]

      action = inputs.action.lower().strip()

      if action not in valid_actions:
          raise ValueError(
              f"Unknown action: {action}. "
              f"Valid actions: {', '.join(valid_actions)}"
          )

      result = action
    output: validated_action

  # ==================== NOTIFY START ====================

  - name: notify_start
    description: "Notify user that action is starting"
    condition: "inputs.channel_id"
    tool: slack_send_message
    args:
      channel_id: "{{ inputs.channel_id }}"
      text: "‚è≥ Starting *{{ validated_action }}*... I'll update you when done."
      thread_ts: "{{ inputs.thread_ts }}"
    output: start_notification
    on_error: continue

  # ==================== EXECUTE ACTIONS ====================

  # Action: start_work
  - name: execute_start_work
    description: "Execute start_work skill"
    condition: "validated_action == 'start_work' and inputs.issue_key"
    tool: skill_run
    args:
      skill_name: start_work
      inputs: '{"issue_key": "{{ inputs.issue_key }}", "repo": "{{ inputs.repo }}"}'
    output: start_work_result
    on_error: continue

  - name: format_start_work
    condition: "validated_action == 'start_work'"
    compute: |
      if start_work_result:
          response = f"‚úÖ Started work on *{inputs.issue_key}*\n\n{str(start_work_result)[:1000]}"
          success = True
      else:
          response = f"‚ùå Failed to start work on {inputs.issue_key}. Check that the issue exists."
          success = False

      result = {"response": response, "success": success}
    output: start_work_response

  # Action: close_issue
  - name: execute_close_issue
    description: "Execute close_issue skill"
    condition: "validated_action == 'close_issue' and inputs.issue_key"
    tool: skill_run
    args:
      skill_name: close_issue
      inputs: '{"issue_key": "{{ inputs.issue_key }}"}'
    output: close_issue_result
    on_error: continue

  - name: format_close_issue
    condition: "validated_action == 'close_issue'"
    compute: |
      if close_issue_result:
          response = f"‚úÖ Closed *{inputs.issue_key}*\n\n{str(close_issue_result)[:1000]}"
          success = True
      else:
          response = f"‚ùå Failed to close {inputs.issue_key}."
          success = False

      result = {"response": response, "success": success}
    output: close_issue_response

  # Action: review_pr
  - name: execute_review_pr
    description: "Execute review_pr skill"
    condition: "validated_action == 'review_pr' and inputs.mr_id"
    tool: skill_run
    args:
      skill_name: review_pr
      inputs: '{"mr_id": {{ inputs.mr_id }}}'
    output: review_pr_result
    on_error: continue

  - name: format_review_pr
    condition: "validated_action == 'review_pr'"
    compute: |
      if review_pr_result:
          response = f"‚úÖ Reviewed *!{inputs.mr_id}*\n\n{str(review_pr_result)[:1000]}"
          success = True
      else:
          response = f"‚ùå Failed to review !{inputs.mr_id}."
          success = False

      result = {"response": response, "success": success}
    output: review_pr_response

  # Action: rebase_pr
  - name: execute_rebase_pr
    description: "Execute rebase_pr skill"
    condition: "validated_action == 'rebase_pr' and inputs.mr_id"
    tool: skill_run
    args:
      skill_name: rebase_pr
      inputs: '{"mr_id": {{ inputs.mr_id }}, "force_push": true}'
    output: rebase_pr_result
    on_error: continue

  - name: format_rebase_pr
    condition: "validated_action == 'rebase_pr'"
    compute: |
      if rebase_pr_result:
          response = f"‚úÖ Rebased *!{inputs.mr_id}*\n\n{str(rebase_pr_result)[:1000]}"
          success = True
      else:
          response = f"‚ùå Failed to rebase !{inputs.mr_id}."
          success = False

      result = {"response": response, "success": success}
    output: rebase_pr_response

  # Action: sync_branch
  - name: execute_sync_branch
    description: "Execute sync_branch skill"
    condition: "validated_action == 'sync_branch'"
    tool: skill_run
    args:
      skill_name: sync_branch
      inputs: '{"repo": "{{ inputs.repo }}"}'
    output: sync_branch_result
    on_error: continue

  - name: format_sync_branch
    condition: "validated_action == 'sync_branch'"
    compute: |
      if sync_branch_result:
          response = f"‚úÖ Branch synced with main\n\n{str(sync_branch_result)[:1000]}"
          success = True
      else:
          response = f"‚ùå Failed to sync branch."
          success = False

      result = {"response": response, "success": success}
    output: sync_branch_response

  # Action: debug_prod
  - name: execute_debug_prod
    description: "Execute debug_prod skill"
    condition: "validated_action == 'debug_prod' and inputs.namespace"
    tool: skill_run
    args:
      skill_name: debug_prod
      inputs: '{"namespace": "{{ inputs.namespace }}"}'
    output: debug_prod_result
    on_error: continue

  - name: format_debug_prod
    condition: "validated_action == 'debug_prod'"
    compute: |
      if debug_prod_result:
          response = f"üîç *Debug Report for {inputs.namespace}*\n\n{str(debug_prod_result)[:1500]}"
          success = True
      else:
          response = f"‚ùå Failed to debug {inputs.namespace}."
          success = False

      result = {"response": response, "success": success}
    output: debug_prod_response

  # Action: jira_hygiene
  - name: execute_jira_hygiene
    description: "Execute jira_hygiene skill"
    condition: "validated_action == 'jira_hygiene' and inputs.issue_key"
    tool: skill_run
    args:
      skill_name: jira_hygiene
      inputs: '{"issue_key": "{{ inputs.issue_key }}", "auto_fix": true}'
    output: jira_hygiene_result
    on_error: continue

  - name: format_jira_hygiene
    condition: "validated_action == 'jira_hygiene'"
    compute: |
      if jira_hygiene_result:
          response = f"‚úÖ Jira hygiene check for *{inputs.issue_key}*\n\n{str(jira_hygiene_result)[:1000]}"
          success = True
      else:
          response = f"‚ùå Failed to check {inputs.issue_key}."
          success = False

      result = {"response": response, "success": success}
    output: jira_hygiene_response

  # Action: standup_summary
  - name: execute_standup
    description: "Execute standup_summary skill"
    condition: "validated_action == 'standup_summary'"
    tool: skill_run
    args:
      skill_name: standup_summary
      inputs: '{"days": 1}'
    output: standup_result
    on_error: continue

  - name: format_standup
    condition: "validated_action == 'standup_summary'"
    compute: |
      if standup_result:
          response = f"üìä *Daily Standup Summary*\n\n{str(standup_result)[:1500]}"
          success = True
      else:
          response = f"‚ùå Failed to generate standup."
          success = False

      result = {"response": response, "success": success}
    output: standup_response

  # Action: create_mr
  - name: execute_create_mr
    description: "Execute create_mr skill"
    condition: "validated_action == 'create_mr' and inputs.issue_key"
    tool: skill_run
    args:
      skill_name: create_mr
      inputs: '{"issue_key": "{{ inputs.issue_key }}", "repo": "{{ inputs.repo }}"}'
    output: create_mr_result
    on_error: continue

  - name: format_create_mr
    condition: "validated_action == 'create_mr'"
    compute: |
      if create_mr_result:
          response = f"‚úÖ Created MR for *{inputs.issue_key}*\n\n{str(create_mr_result)[:1000]}"
          success = True
      else:
          response = f"‚ùå Failed to create MR for {inputs.issue_key}."
          success = False

      result = {"response": response, "success": success}
    output: create_mr_response

  # ==================== COLLECT AND SEND RESPONSE ====================

  - name: collect_response
    description: "Collect the appropriate response"
    compute: |
      # Find which handler produced a response
      responses = {
          "start_work": start_work_response if 'start_work_response' in dir() else None,
          "close_issue": close_issue_response if 'close_issue_response' in dir() else None,
          "review_pr": review_pr_response if 'review_pr_response' in dir() else None,
          "rebase_pr": rebase_pr_response if 'rebase_pr_response' in dir() else None,
          "sync_branch": sync_branch_response if 'sync_branch_response' in dir() else None,
          "debug_prod": debug_prod_response if 'debug_prod_response' in dir() else None,
          "jira_hygiene": jira_hygiene_response if 'jira_hygiene_response' in dir() else None,
          "standup_summary": standup_response if 'standup_response' in dir() else None,
          "create_mr": create_mr_response if 'create_mr_response' in dir() else None,
      }

      response_data = responses.get(validated_action)

      if not response_data:
          response_data = {
              "response": f"‚ùå Action '{validated_action}' completed but no response was generated.",
              "success": False
          }

      result = response_data
    output: final_response

  - name: send_final_response
    description: "Send final response to Slack"
    condition: "inputs.channel_id"
    tool: slack_send_message
    args:
      channel_id: "{{ inputs.channel_id }}"
      text: "{{ final_response.response }}"
      thread_ts: "{{ inputs.thread_ts }}"
    output: send_result
    on_error: continue

  - name: mark_processed
    description: "Mark original message as processed"
    condition: "inputs.message_id"
    tool: slack_mark_processed
    args:
      message_id: "{{ inputs.message_id }}"
    output: mark_result
    on_error: continue

outputs:
  - name: result
    value: "{{ final_response }}"

