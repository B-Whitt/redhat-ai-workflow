# Skill: API Smoke Test
# Endpoint smoke testing for API health

name: api_smoke_test
description: |
  Run smoke tests against API endpoints to verify availability and performance.

  This skill performs:
  - GET/POST/PUT/DELETE endpoint checks
  - Response time measurements
  - HTTP header inspection
  - TLS connection verification
  - Slow endpoint detection

  Uses: curl_get, curl_post, curl_put, curl_delete, curl_head,
        curl_timing, curl_headers, openssl_s_client
version: "1.0"

links:
  depends_on: []
  validates:
    - deploy_to_ephemeral
    - release_to_prod
  chains_to:
    - debug_prod
    - create_jira_issue
    - investigate_alert
  provides_context_for:
    - debug_prod
    - create_jira_issue
  validated_by:
    - environment_overview

inputs:
  - name: base_url
    type: string
    required: true
    description: "Base URL of the API to test (e.g., https://api.example.com)"

  - name: environment
    type: string
    required: false
    default: "stage"
    description: "Environment (stage, production, ephemeral)"

  - name: auth_token
    type: string
    required: false
    default: ""
    description: "Bearer token for authenticated endpoints"

  - name: fail_on_slow
    type: boolean
    required: false
    default: false
    description: "Fail if response time exceeds threshold"

steps:
  # ==================== LOAD DEVELOPER PERSONA ====================

  - name: load_developer_persona
    description: "Load developer persona for HTTP tools"
    tool: persona_load
    args:
      persona_name: "developer"

  # ==================== KNOWLEDGE INTEGRATION ====================

  - name: check_api_known_issues
    description: "Check for known API testing issues"
    compute: |
      curl_issues = memory.check_known_issues("curl", "") or {}
      api_issues = memory.check_known_issues("api", "") or {}

      all_issues = []
      for issues in [curl_issues, api_issues]:
          if issues and issues.get("matches"):
              all_issues.extend(issues.get("matches", [])[:2])

      result = {
          "has_known_issues": len(all_issues) > 0,
          "issues": all_issues[:5],
      }
    output: api_known_issues
    on_error: continue

  # ==================== TLS CHECK ====================

  - name: check_tls
    description: "Verify TLS connection to API"
    tool: openssl_s_client
    args:
      host: "{{ inputs.base_url }}"
    output: tls_check_raw
    on_error: continue

  - name: parse_tls
    description: "Parse TLS results"
    compute: |
      tls_text = str(tls_check_raw) if 'tls_check_raw' in dir() and tls_check_raw else ""
      import re
      tls_match = re.search(r'(TLSv[\d.]+)', tls_text)
      tls_version = tls_match.group(1) if tls_match else "unknown"
      tls_ok = "verify return code: 0" in tls_text.lower() or tls_version != "unknown"

      result = {
          "version": tls_version,
          "ok": tls_ok,
      }
    output: tls_info
    on_error: continue

  # ==================== HTTP CHECKS ====================

  - name: check_get_root
    description: "GET request to root endpoint"
    tool: curl_get
    args:
      url: "{{ inputs.base_url }}/"
    output: get_root_raw
    on_error: continue

  - name: check_get_health
    description: "GET request to health endpoint"
    tool: curl_get
    args:
      url: "{{ inputs.base_url }}/health"
    output: get_health_raw
    on_error: continue

  - name: check_head
    description: "HEAD request to root"
    tool: curl_head
    args:
      url: "{{ inputs.base_url }}/"
    output: head_raw
    on_error: continue

  - name: check_headers
    description: "Inspect response headers"
    tool: curl_headers
    args:
      url: "{{ inputs.base_url }}/"
    output: headers_raw
    on_error: continue

  - name: check_timing
    description: "Measure response timing"
    tool: curl_timing
    args:
      url: "{{ inputs.base_url }}/"
    output: timing_raw
    on_error: continue

  - name: check_post
    description: "POST request smoke test"
    tool: curl_post
    args:
      url: "{{ inputs.base_url }}/api/v1/ping"
    output: post_raw
    on_error: continue

  - name: check_put
    description: "PUT request smoke test"
    tool: curl_put
    args:
      url: "{{ inputs.base_url }}/api/v1/ping"
    output: put_raw
    on_error: continue

  - name: check_delete
    description: "DELETE request smoke test"
    tool: curl_delete
    args:
      url: "{{ inputs.base_url }}/api/v1/ping"
    output: delete_raw
    on_error: continue

  # ==================== ANALYSIS ====================

  - name: parse_results
    description: "Analyze all HTTP responses"
    compute: |
      results = {}
      for name, raw in [
          ("GET /", get_root_raw if 'get_root_raw' in dir() else None),
          ("GET /health", get_health_raw if 'get_health_raw' in dir() else None),
          ("HEAD /", head_raw if 'head_raw' in dir() else None),
          ("POST /api/v1/ping", post_raw if 'post_raw' in dir() else None),
          ("PUT /api/v1/ping", put_raw if 'put_raw' in dir() else None),
          ("DELETE /api/v1/ping", delete_raw if 'delete_raw' in dir() else None),
      ]:
          text = str(raw) if raw else ""
          import re
          status_match = re.search(r'HTTP/[\d.]+\s+(\d{3})', text)
          status = int(status_match.group(1)) if status_match else 0
          ok = 200 <= status < 500 if status else False
          results[name] = {"status": status, "ok": ok}

      total = len(results)
      passed = sum(1 for r in results.values() if r["ok"])
      failed = total - passed

      result = {
          "endpoints": results,
          "total": total,
          "passed": passed,
          "failed": failed,
          "all_ok": failed == 0,
      }
    output: smoke_results

  - name: parse_timing
    description: "Parse response timing"
    compute: |
      timing_text = str(timing_raw) if 'timing_raw' in dir() and timing_raw else ""
      import re

      total_match = re.search(r'total[:\s]+([\d.]+)', timing_text.lower())
      total_time = float(total_match.group(1)) if total_match else 0.0

      connect_match = re.search(r'connect[:\s]+([\d.]+)', timing_text.lower())
      connect_time = float(connect_match.group(1)) if connect_match else 0.0

      slow = total_time > 2.0

      result = {
          "total_seconds": total_time,
          "connect_seconds": connect_time,
          "slow": slow,
          "raw": timing_text[:300] if timing_text else "",
      }
    output: timing_analysis
    on_error: continue

  # ==================== LEARNING FROM FAILURES ====================

  - name: detect_api_smoke_failures
    description: "Detect failure patterns from API smoke test"
    compute: |
      errors_detected = []

      get_text = str(get_root_raw) if 'get_root_raw' in dir() and get_root_raw else ""
      tls_text = str(tls_check_raw) if 'tls_check_raw' in dir() and tls_check_raw else ""
      combined = get_text + tls_text

      if "could not resolve" in combined.lower():
          errors_detected.append({
              "tool": "curl_get",
              "pattern": "could not resolve",
              "cause": "DNS resolution failed for target host",
              "fix": "Verify hostname and DNS configuration"
          })
      if "connection refused" in combined.lower():
          errors_detected.append({
              "tool": "curl_get",
              "pattern": "connection refused",
              "cause": "Service not running or port not open",
              "fix": "Check that the API service is running"
          })
      if "no route to host" in combined.lower():
          errors_detected.append({
              "tool": "curl_get",
              "pattern": "no route to host",
              "cause": "Network unreachable - VPN may be required",
              "fix": "Run vpn_connect() to connect to Red Hat VPN"
          })

      result = errors_detected
    output: api_smoke_errors_detected
    on_error: continue

  - name: learn_api_smoke_dns_failure
    description: "Learn from DNS resolution failures"
    condition: "api_smoke_errors_detected and any(e.get('pattern') == 'could not resolve' for e in api_smoke_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "curl_get"
      error_pattern: "could not resolve"
      root_cause: "DNS resolution failed for target host"
      fix_description: "Verify hostname and DNS configuration"
    output: api_smoke_dns_fix_learned
    on_error: continue

  - name: log_session
    description: "Log API smoke test to session"
    tool: memory_session_log
    args:
      action: "API smoke test on {{ inputs.base_url }}"
      details: "environment={{ inputs.environment }}, passed={{ smoke_results.passed if smoke_results else 0 }}/{{ smoke_results.total if smoke_results else 0 }}"
    on_error: continue

outputs:
  - name: report
    value: |
      ## API Smoke Test: {{ inputs.base_url }}

      **Environment:** {{ inputs.environment }}
      **TLS:** {{ tls_info.version if tls_info else "unknown" }} ({{ "OK" if tls_info and tls_info.ok else "FAILED" }})

      ---

      ### Endpoint Results ({{ smoke_results.passed }}/{{ smoke_results.total }} passed)

      | Endpoint | Status | Result |
      |----------|--------|--------|
      {% for ep, info in smoke_results.endpoints.items() %}
      | `{{ ep }}` | {{ info.status }} | {{ "PASS" if info.ok else "FAIL" }} |
      {% endfor %}

      ---

      ### Response Timing

      {% if timing_analysis is defined and timing_analysis %}
      | Metric | Value |
      |--------|-------|
      | Total | {{ timing_analysis.total_seconds }}s |
      | Connect | {{ timing_analysis.connect_seconds }}s |
      | Slow | {{ "YES" if timing_analysis.slow else "No" }} |

      {% if timing_analysis.slow %}
      **WARNING:** Response time exceeds 2 second threshold.
      {% endif %}
      {% else %}
      Timing data unavailable.
      {% endif %}

      ---

      ### Response Headers

      ```
      {{ headers_raw | string | truncate(500) if headers_raw else "No headers captured" }}
      ```

      {% if not smoke_results.all_ok %}
      ---

      ### Action Required

      {{ smoke_results.failed }} endpoint(s) failed. Investigate with:
      ```
      skill_run(skill_name="debug_prod", inputs='{"namespace": "main"}')
      ```
      {% endif %}

      {% if api_known_issues and api_known_issues.has_known_issues %}
      ---

      ### Known Issues

      {% for issue in api_known_issues.issues[:3] %}
      - {{ issue.pattern if issue.pattern else issue }}
      {% endfor %}
      {% endif %}
