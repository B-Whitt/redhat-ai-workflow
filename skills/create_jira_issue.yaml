# Skill: Create Jira Issue
# Create new Jira issues with linking and assignment
# Enhanced with semantic code search for context-rich issues

name: create_jira_issue
description: |
  Create a new Jira issue with proper linking and team notification.

  **Enhanced with Semantic Search:**
  - Searches codebase for related code based on issue summary
  - Adds relevant file references to issue description
  - Identifies potential areas of impact
  - Suggests related components/modules

  Use for:
  - Creating bug reports (with relevant code context)
  - Creating feature requests (with implementation hints)
  - Creating sub-tasks
  - Linking related issues

  The skill will:
  1. Search codebase for related code (semantic search)
  2. Create the issue with enriched description
  3. Link to related issues
  4. Transition to appropriate status
  5. Notify team channel via Slack

version: "1.2"

links:
  depends_on: []            # Standalone - creates new issues
  validates: []             # Issue creation doesn't validate other skills
  validated_by:
    - start_work            # If work starts successfully, issue was created correctly
    - jira_hygiene          # Hygiene validates issue completeness
    - pr_jira_audit
    - sprint_planning
  chains_to:
    - start_work            # Start working on the new issue
    - jira_hygiene          # Run hygiene on the newly created issue
    - sprint_planning       # Add new issue to sprint
    - clone_jira_issue
    - notify_team           # Notify team about new issue creation
  provides_context_for:
    - start_work            # Issue key for branch creation
    - clone_jira_issue      # Template for cloning
    - standup_summary       # New issues for standup
    - weekly_summary        # New issues for weekly report

inputs:
  - name: summary
    type: string
    required: true
    description: "Issue summary/title"

  - name: description
    type: string
    required: false
    default: ""
    description: "Issue description (markdown supported)"

  - name: issue_type
    type: string
    required: false
    default: "Task"
    description: "Issue type: 'Bug', 'Task', 'Story', 'Sub-task'"

  - name: project
    type: string
    required: false
    default: "AAP"
    description: "Jira project key"

  - name: repo
    type: string
    required: false
    default: "automation-analytics-backend"
    description: "Repository to search for related code"

  - name: search_code
    type: boolean
    required: false
    default: true
    description: "Search codebase for related code (semantic search)"

  - name: notify_team
    type: boolean
    required: false
    default: true
    description: "Send Slack notification to team channel about the new issue"

  - name: labels
    type: string
    required: false
    description: "Comma-separated labels"

  - name: priority
    type: string
    required: false
    default: "normal"
    description: "Priority: 'blocker', 'critical', 'major', 'normal', 'minor' (or: 'highest', 'high', 'medium', 'low', 'lowest')"

  - name: link_to
    type: string
    required: false
    description: "Issue key to link to (e.g., AAP-12345)"

  - name: link_type
    type: string
    required: false
    default: "relates to"
    description: "Link type: 'relates to', 'blocks', 'is blocked by', 'duplicates'"

  - name: start_progress
    type: boolean
    required: false
    default: false
    description: "Immediately transition to In Progress"

  - name: slack_format
    type: boolean
    required: false
    default: false
    description: "Use Slack link format in report"

  # AAP project required fields
  - name: problem_description
    type: string
    required: false
    default: ""
    description: "Problem description (required by AAP, falls back to description)"

  # Story-specific fields (required for AAP project stories)
  - name: user_story
    type: string
    required: false
    default: ""
    description: "User story text (for Story type): 'As a..., I want..., so that...'"

  - name: acceptance_criteria
    type: string
    required: false
    default: ""
    description: "Acceptance criteria (for Story type)"

  - name: definition_of_done
    type: string
    required: false
    default: ""
    description: "Definition of done (for Story type)"

  - name: components
    type: string
    required: false
    default: ""
    description: "Comma-separated components (e.g., 'Automation Analytics')"

steps:
  # ==================== LOAD DEVELOPER PERSONA ====================
  # This skill uses jira_basic tools

  - name: load_developer_persona
    description: "Load developer persona for Jira tools"
    tool: persona_load
    args:
      persona_name: "developer"

  - name: init_autoheal
    description: "Initialize failure tracking"
    compute: |
      result = {"jira_failures": []}
    output: autoheal_state
    on_error: continue

  # ==================== KNOWLEDGE INTEGRATION ====================

  - name: check_jira_known_issues
    description: "Check for known Jira issues"
    compute: |
      # Check known issues for Jira operations
      jira_issues = memory.check_known_issues("jira", "") or {}
      issue_issues = memory.check_known_issues("issue_create", "") or {}

      all_issues = []
      for issues in [jira_issues, issue_issues]:
          if issues and issues.get("matches"):
              all_issues.extend(issues.get("matches", [])[:2])

      result = {
          "has_known_issues": len(all_issues) > 0,
          "issues": all_issues[:5],
      }
    output: jira_known_issues
    on_error: continue

  - name: get_jira_best_practices
    description: "Get Jira best practices from knowledge"
    tool: knowledge_query
    args:
      project: "automation-analytics-backend"
      persona: "developer"
      section: "patterns"
    output: jira_practices_raw
    on_error: continue

  - name: parse_jira_practices
    description: "Parse Jira best practices"
    compute: |
      practices_result = jira_practices_raw if 'jira_practices_raw' in dir() and jira_practices_raw else {}

      jira_practices = []
      if isinstance(practices_result, dict) and practices_result.get('found'):
          content = practices_result.get('content', {})
          if isinstance(content, dict):
              # Get coding patterns that might relate to Jira
              coding = content.get('coding', [])
              if isinstance(coding, list):
                  for p in coding:
                      p_str = str(p).lower()
                      if any(kw in p_str for kw in ['jira', 'issue', 'ticket', 'story', 'bug', 'task']):
                          jira_practices.append(p)

      result = {
          'practices': jira_practices[:5],
          'has_practices': len(jira_practices) > 0,
      }
    output: jira_best_practices
    on_error: continue

  # ==================== SEMANTIC CODE SEARCH ====================

  - name: search_related_code
    description: "Search codebase for code related to the issue"
    condition: "inputs.search_code"
    tool: code_search
    args:
      query: "{{ inputs.summary }}"
      project: "{{ inputs.repo }}"
      limit: 5
    output: code_search_raw
    on_error: continue

  - name: parse_code_search
    description: "Parse semantic search results"
    condition: "inputs.search_code"
    compute: |
      import re

      search_result = code_search_raw if 'code_search_raw' in dir() and code_search_raw else ""
      search_text = str(search_result) if search_result else ""

      related_files = []
      code_snippets = []
      modules_affected = set()

      # Parse the markdown output from code_search
      # Format: ### 1. `file_path` (lines X-Y)
      file_pattern = r'###\s*\d+\.\s*`([^`]+)`\s*\(lines\s*(\d+)-(\d+)\)'
      type_pattern = r'\*\*Type:\*\*\s*(\w+)\s*\|\s*\*\*Name:\*\*\s*(\w+)\s*\|\s*\*\*Relevance:\*\*\s*(\d+)%'

      matches = re.findall(file_pattern, search_text)
      type_matches = re.findall(type_pattern, search_text)

      for i, (file_path, start_line, end_line) in enumerate(matches[:5]):
          # Extract module/component from path
          parts = file_path.split('/')
          if len(parts) > 1:
              module = parts[0] if parts[0] not in ['src', 'app', 'lib'] else (parts[1] if len(parts) > 1 else parts[0])
              modules_affected.add(module)

          file_info = {
              'path': file_path,
              'start_line': int(start_line),
              'end_line': int(end_line),
              'type': type_matches[i][0] if i < len(type_matches) else 'unknown',
              'name': type_matches[i][1] if i < len(type_matches) else 'unknown',
              'relevance': int(type_matches[i][2]) if i < len(type_matches) else 0,
          }
          related_files.append(file_info)

      # Extract code snippets (first 3 high-relevance ones)
      code_blocks = re.findall(r'```\w+\n(.*?)```', search_text, re.DOTALL)
      for i, block in enumerate(code_blocks[:3]):
          if len(block.strip()) > 20:  # Skip tiny snippets
              code_snippets.append({
                  'code': block.strip()[:500],  # Limit size
                  'file': related_files[i]['path'] if i < len(related_files) else 'unknown',
              })

      result = {
          'found': len(related_files) > 0,
          'files': related_files,
          'modules': list(modules_affected),
          'snippets': code_snippets,
          'file_count': len(related_files),
          'high_relevance_count': sum(1 for f in related_files if f.get('relevance', 0) >= 60),
      }
    output: code_context
    on_error: continue

  - name: build_enhanced_description
    description: "Build enhanced description with code context"
    compute: |
      original_desc = inputs.get('description', '') or ''
      code_ctx = code_context if 'code_context' in dir() and code_context else {}

      enhanced_desc = original_desc

      # Add code context section if we found related code
      if code_ctx.get('found') and code_ctx.get('files'):
          if enhanced_desc:
              enhanced_desc += "\n\n"

          enhanced_desc += "---\n\n"
          enhanced_desc += "h3. üîç Related Code (auto-discovered)\n\n"

          # List affected modules
          if code_ctx.get('modules'):
              enhanced_desc += "*Potentially affected modules:* " + ", ".join(code_ctx['modules'][:5]) + "\n\n"

          # List relevant files
          enhanced_desc += "*Relevant files:*\n"
          for f in code_ctx.get('files', [])[:5]:
              relevance_indicator = "üü¢" if f.get('relevance', 0) >= 70 else "üü°" if f.get('relevance', 0) >= 40 else "‚ö™"
              enhanced_desc += f"* {relevance_indicator} {{{{code}}}}{f['path']}{{{{code}}}} (lines {f['start_line']}-{f['end_line']}) - {f.get('type', 'code')}: {f.get('name', 'unknown')}\n"

          # Add note about semantic search
          enhanced_desc += "\n_Code references discovered via semantic search based on issue summary._\n"

      result = {
          'description': enhanced_desc,
          'was_enhanced': code_ctx.get('found', False),
          'files_added': code_ctx.get('file_count', 0),
      }
    output: enhanced_description
    on_error: continue

  # ==================== CREATE ISSUE ====================

  - name: create_issue
    description: "Create the Jira issue with enhanced description"
    tool: jira_create_issue
    args:
      project: "{{ inputs.project }}"
      summary: "{{ inputs.summary }}"
      description: "{{ enhanced_description.description if enhanced_description and enhanced_description.description else (inputs.description or '') }}"
      problem_description: "{{ inputs.problem_description or inputs.description or inputs.summary }}"
      issue_type: "{{ inputs.issue_type }}"
      priority: "{{ inputs.priority }}"
      labels: "{{ inputs.labels or '' }}"
      user_story: "{{ inputs.user_story or '' }}"
      acceptance_criteria: "{{ inputs.acceptance_criteria or '' }}"
      definition_of_done: "{{ inputs.definition_of_done or '' }}"
      components: "{{ inputs.components or '' }}"
    output: create_result
    on_error: continue

  - name: parse_create_result
    description: "Parse issue creation result"
    compute: |
      result_text = str(create_result) if create_result else ""

      # Extract issue key
      import re
      issue_key = None
      key_match = re.search(r'([A-Z]+-\d+)', result_text)
      if key_match:
          issue_key = key_match.group(1)

      success = issue_key is not None or ("created" in result_text.lower() and "error" not in result_text.lower())

      result = {
          "success": success,
          "issue_key": issue_key,
          "message": result_text[:300] if result_text else "No response",
      }
    output: create_status

  # ==================== LINK ISSUES ====================

  - name: link_issues
    description: "Link to related issue"
    condition: "create_status.issue_key and inputs.link_to"
    tool: jira_add_link
    args:
      from_issue: "{{ create_status.issue_key }}"
      to_issue: "{{ inputs.link_to }}"
      link_type: "{{ inputs.link_type }}"
    output: link_result
    on_error: continue

  - name: parse_link
    description: "Parse link result"
    condition: "link_result"
    compute: |
      link_text = str(link_result) if link_result else ""

      success = "error" not in link_text.lower()

      result = {
          "success": success,
          "message": link_text[:200] if link_text else "Unknown",
      }
    output: link_status
    on_error: continue

  # ==================== UPDATE ISSUE (add more fields) ====================

  - name: update_issue
    description: "Update issue with additional fields"
    condition: "create_status.issue_key and inputs.labels"
    tool: jira_update_issue
    args:
      issue_key: "{{ create_status.issue_key }}"
      fields: "labels"
      values: "{{ inputs.labels }}"
    output: update_result
    on_error: continue

  # ==================== TRANSITION ====================

  - name: transition_to_progress
    description: "Transition to In Progress"
    condition: "create_status.issue_key and inputs.start_progress"
    tool: jira_transition
    args:
      issue_key: "{{ create_status.issue_key }}"
      transition: "Start Progress"
    output: transition_result
    on_error: auto_heal  # Jira API - may need auth refresh

  # ==================== GET FINAL STATE ====================

  - name: get_issue
    description: "Get the created issue details"
    condition: "create_status.issue_key"
    tool: jira_view_issue
    args:
      issue_key: "{{ create_status.issue_key }}"
    output: issue_details
    on_error: auto_heal  # Jira API - may need auth refresh

  # ==================== MEMORY ====================

  - name: log_creation
    description: "Log issue creation"
    condition: "create_status.success"
    tool: memory_session_log
    args:
      action: "Created Jira issue {{ create_status.issue_key }}"
      details: "{{ inputs.summary[:50] }}{% if inputs.link_to %}, linked to {{ inputs.link_to }}{% endif %}"
    on_error: continue

  - name: track_issue_creations
    description: "Track issue creations for patterns"
    condition: "create_status and create_status.success"
    compute: |
      from datetime import datetime

      # Load patterns
      patterns = memory.read_memory("learned/patterns") or {}
      if "issue_creations" not in patterns:
          patterns["issue_creations"] = []

      # Record this creation
      creation_record = {
          "issue_key": create_status.issue_key if create_status else None,
          "project": inputs.project,
          "issue_type": inputs.issue_type,
          "priority": inputs.priority,
          "linked_to": inputs.link_to if inputs.link_to else None,
          "code_context_added": enhanced_description.was_enhanced if enhanced_description else False,
          "files_referenced": enhanced_description.files_added if enhanced_description else 0,
          "timestamp": datetime.now().isoformat(),
      }

      patterns["issue_creations"].append(creation_record)

      # Keep last 100 creations
      patterns["issue_creations"] = patterns["issue_creations"][-100:]

      memory.write_memory("learned/patterns", patterns)
      result = "creation tracked"
    output: creation_tracking_result
    on_error: continue

  - name: add_to_active_issues
    description: "Add created issue to active issues"
    condition: "create_status and create_status.success"
    tool: memory_append
    args:
      key: "state/current_work"
      list_path: "active_issues"
      item: |
        key: {{ create_status.issue_key }}
        status: {{ "In Progress" if inputs.start_progress else "New" }}
        type: {{ inputs.issue_type }}
        summary: {{ inputs.summary[:60] }}
        created: {{ today }}
    on_error: continue

  # ==================== NOTIFY TEAM ====================

  - name: build_notification_message
    description: "Build Slack notification message for the new issue"
    condition: "create_status and create_status.success and inputs.notify_team"
    compute: |
      issue_key = create_status.get('issue_key', 'Unknown')
      summary = inputs.get('summary', 'No summary')
      issue_type = inputs.get('issue_type', 'Task')
      priority = inputs.get('priority', 'Medium')

      # Build message with Slack link format
      message = f"New {issue_type} created: <https://issues.redhat.com/browse/{issue_key}|{issue_key}> - {summary}\n\n*Priority:* {priority}"

      # Add link info if present
      link_to = inputs.get('link_to')
      if link_to:
          message += f"\n*Linked to:* <https://issues.redhat.com/browse/{link_to}|{link_to}>"

      result = {
          "message": message,
          "type": "info",
      }
    output: notification_message
    on_error: continue

  - name: notify_team_channel
    description: "Send Slack notification to team channel"
    condition: "create_status and create_status.success and inputs.notify_team and notification_message"
    tool: skill_run
    args:
      skill_name: "notify_team"
      inputs: '{"message": "{{ notification_message.message }}", "type": "{{ notification_message.type }}"}'
    output: notify_result
    on_error: continue

  - name: parse_notify_result
    description: "Parse notification result"
    condition: "notify_result"
    compute: |
      notify_text = str(notify_result) if notify_result else ""
      success = "success" in notify_text.lower() or "sent" in notify_text.lower()

      result = {
          "success": success,
          "message": notify_text[:200] if notify_text else "Unknown",
      }
    output: notify_status
    on_error: continue

  # ==================== LEARNING FROM FAILURES ====================

  - name: detect_create_failures
    description: "Detect failure patterns from issue creation"
    compute: |
      errors_detected = []

      # Check Jira API failures
      create_text = str(create_result) if 'create_result' in dir() and create_result else ""

      if "unauthorized" in create_text.lower() or "401" in create_text:
          errors_detected.append({
              "tool": "jira_create_issue",
              "pattern": "unauthorized",
              "cause": "Jira authentication failed or token expired",
              "fix": "Check Jira credentials in config.json"
          })
      if "project" in create_text.lower() and "not found" in create_text.lower():
          errors_detected.append({
              "tool": "jira_create_issue",
              "pattern": "project not found",
              "cause": "Jira project key is incorrect",
              "fix": "Verify project key (e.g., AAP, RHCLOUD)"
          })
      if "issue type" in create_text.lower() and "not found" in create_text.lower():
          errors_detected.append({
              "tool": "jira_create_issue",
              "pattern": "issue type not found",
              "cause": "Issue type doesn't exist in this project",
              "fix": "Use valid types: Story, Bug, Task, Epic"
          })

      result = errors_detected
    output: create_errors_detected
    on_error: continue

  - name: learn_jira_create_auth_failure
    description: "Learn from Jira auth failures"
    condition: "create_errors_detected and any(e.get('pattern') == 'unauthorized' for e in create_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "jira_create_issue"
      error_pattern: "unauthorized"
      root_cause: "Jira authentication failed or token expired"
      fix_description: "Check Jira credentials in config.json"
    output: create_auth_fix_learned
    on_error: continue

  - name: learn_jira_project_failure
    description: "Learn from project not found failures"
    condition: "create_errors_detected and any(e.get('pattern') == 'project not found' for e in create_errors_detected)"
    tool: learn_tool_fix
    args:
      tool_name: "jira_create_issue"
      error_pattern: "project not found"
      root_cause: "Jira project key is incorrect"
      fix_description: "Verify project key (e.g., AAP, RHCLOUD)"
    output: project_fix_learned
    on_error: continue

outputs:
  - name: report
    value: |
      {% set is_slack = inputs.slack_format | default(true) %}
      ## üé´ Create Jira Issue

      {% if create_status.success %}
      ### ‚úÖ Issue Created

      {% if is_slack %}
      **Key:** <https://issues.redhat.com/browse/{{ create_status.issue_key }}|{{ create_status.issue_key }}>
      {% else %}
      **Key:** [{{ create_status.issue_key }}](https://issues.redhat.com/browse/{{ create_status.issue_key }})
      {% endif %}
      **Summary:** {{ inputs.summary }}
      **Type:** {{ inputs.issue_type }}
      **Priority:** {{ inputs.priority }}

      {% if notify_status and notify_status.success %}
      **Team notified:** ‚úÖ Slack notification sent
      {% elif inputs.notify_team and not notify_status %}
      **Team notified:** ‚ö†Ô∏è Notification failed
      {% endif %}

      {% if link_status and link_status.success %}
      {% if is_slack %}
      **Linked to:** <https://issues.redhat.com/browse/{{ inputs.link_to }}|{{ inputs.link_to }}> ({{ inputs.link_type }})
      {% else %}
      **Linked to:** [{{ inputs.link_to }}](https://issues.redhat.com/browse/{{ inputs.link_to }}) ({{ inputs.link_type }})
      {% endif %}
      {% elif inputs.link_to and not link_status.success %}
      ‚ö†Ô∏è Link to {{ inputs.link_to }} failed: {{ link_status.message }}
      {% endif %}

      {% if inputs.start_progress %}
      **Status:** In Progress
      {% endif %}

      ---

      ### Next Steps

      **View issue:**
      ```python
      jira_view_issue(issue_key='{{ create_status.issue_key }}')
      ```

      **Start working:**
      ```python
      skill_run("start_work", '{"issue_key": "{{ create_status.issue_key }}"}')
      ```

      **Add comment:**
      ```python
      jira_add_comment(issue_key='{{ create_status.issue_key }}', comment='...')
      ```

      {% else %}
      ### ‚ùå Creation Failed

      {{ create_status.message }}

      Check:
      - Project key is valid ({{ inputs.project }})
      - Issue type exists ({{ inputs.issue_type }})
      - You have permission to create issues

      {% endif %}

      {% if jira_best_practices and jira_best_practices.has_practices %}
      ---

      ### üìã Jira Best Practices

      {% for practice in jira_best_practices.practices[:3] %}
      - {{ practice }}
      {% endfor %}
      {% endif %}

      {% if jira_known_issues and jira_known_issues.has_known_issues %}
      ---

      ### üí° Known Issues

      {% for issue in jira_known_issues.issues[:3] %}
      - {{ issue.pattern if issue.pattern else issue }}
      {% endfor %}
      {% endif %}

      {% if code_context and code_context.found %}
      ---

      ### üîç Code Context (Semantic Search)

      {% if enhanced_description and enhanced_description.was_enhanced %}
      ‚úÖ Issue description enhanced with {{ code_context.file_count }} related file(s)
      {% endif %}

      **Potentially affected modules:** {{ code_context.modules | join(', ') if code_context.modules else 'None identified' }}

      **Related files found:**
      {% for f in code_context.files[:5] %}
      - {% if f.relevance >= 70 %}üü¢{% elif f.relevance >= 40 %}üü°{% else %}‚ö™{% endif %} `{{ f.path }}` ({{ f.relevance }}% match) - {{ f.type }}: {{ f.name }}
      {% endfor %}

      {% if code_context.high_relevance_count > 0 %}
      üìä {{ code_context.high_relevance_count }} high-relevance match(es) found
      {% endif %}
      {% elif inputs.search_code %}
      ---

      ### üîç Code Context

      ‚ö†Ô∏è No related code found via semantic search. The codebase may not be indexed.

      To index: `code_index("{{ inputs.repo }}")`
      {% endif %}

  - name: context
    value:
      issue_key: "{{ create_status.issue_key }}"
      created: "{{ create_status.success }}"
      linked: "{{ link_status.success if link_status else false }}"
      link_to: "{{ inputs.link_to }}"
      notified: "{{ notify_status.success if notify_status else false }}"
