# Skill: Create Merge Request
# Creates a properly formatted MR with Jira link, validation, and quality checks

name: create_mr
description: |
  Create a merge request with full validation:
  - Automatically resolves repo and GitLab project from issue key if not provided
  - Checks for uncommitted changes
  - Validates commit message format (AAP-XXXXX)
  - Runs black/flake8 linting
  - Checks if branch can merge cleanly
  - Optionally runs jira_hygiene first
  - Creates MR with proper description
  - Links to Jira and updates status
version: "2.1"

inputs:
  - name: issue_key
    type: string
    required: true
    description: "Jira issue key for linking (e.g., AAP-12345)"

  - name: repo
    type: string
    required: false
    default: ""
    description: "Repository path - if not provided, resolved from issue key via config"

  - name: repo_name
    type: string
    required: false
    description: "Repository name from config (e.g., 'automation-analytics-backend')"

  - name: draft
    type: boolean
    required: false
    default: true
    description: "Create as draft MR"

  - name: target_branch
    type: string
    required: false
    default: ""
    description: "Target branch for MR (defaults to repo's default_branch from config)"

  - name: run_linting
    type: boolean
    required: false
    default: true
    description: "Run black/flake8 before creating MR"

  - name: check_jira
    type: boolean
    required: false
    default: true
    description: "Run jira_hygiene check before creating MR"

  - name: auto_fix_lint
    type: boolean
    required: false
    default: false
    description: "Auto-fix linting issues with black"

# Note: constants are now resolved dynamically from config
constants:
  jira_url: https://issues.redhat.com

steps:
  # ==================== RESOLVE REPOSITORY ====================

  - name: resolve_repo
    description: "Determine which repo and GitLab project to use"
    compute: |
      import json
      import os
      from pathlib import Path

      repo_path = None
      gitlab_project = None
      default_branch = "main"
      repo_config = {}

      # Load config
      config_paths = [
          Path.cwd() / "config.json",
          Path.home() / "src/redhat-ai-workflow/config.json",
      ]
      config = {}
      for p in config_paths:
          if p.exists():
              with open(p) as f:
                  config = json.load(f)
              break

      repos = config.get("repositories", {})

      # Explicit repo path takes priority
      if inputs.repo and inputs.repo != "" and inputs.repo != ".":
          repo_path = inputs.repo
          # Try to find matching config for GitLab project
          for name, cfg in repos.items():
              if cfg.get("path") == repo_path:
                  gitlab_project = cfg.get("gitlab")
                  default_branch = cfg.get("default_branch", "main")
                  repo_config = cfg
                  break
      # Then repo name from config
      elif inputs.repo_name:
          if inputs.repo_name in repos:
              repo_config = repos[inputs.repo_name]
              repo_path = repo_config.get("path", "")
              gitlab_project = repo_config.get("gitlab")
              default_branch = repo_config.get("default_branch", "main")
          else:
              raise ValueError(f"Repository '{inputs.repo_name}' not found in config.json")
      # Finally, resolve from issue key prefix
      else:
          project_prefix = inputs.issue_key.split("-")[0].upper()
          matching = []
          for name, cfg in repos.items():
              if cfg.get("jira_project") == project_prefix:
                  matching.append({"name": name, "config": cfg})

          if len(matching) == 0:
              # Fall back to cwd if we're in a git repo
              cwd = os.getcwd()
              if os.path.exists(os.path.join(cwd, ".git")):
                  repo_path = cwd
                  # Try to match to config
                  for name, cfg in repos.items():
                      if cfg.get("path") == cwd:
                          gitlab_project = cfg.get("gitlab")
                          default_branch = cfg.get("default_branch", "main")
                          repo_config = cfg
                          break
              else:
                  raise ValueError(
                      f"No repository configured for {project_prefix} issues. "
                      "Please specify 'repo' or 'repo_name'."
                  )
          elif len(matching) == 1:
              repo_config = matching[0]["config"]
              repo_path = repo_config.get("path")
              gitlab_project = repo_config.get("gitlab")
              default_branch = repo_config.get("default_branch", "main")
          else:
              names = ", ".join(m["name"] for m in matching)
              raise ValueError(
                  f"Multiple repositories match {project_prefix}: {names}. "
                  "Please specify 'repo_name'."
              )

      if not repo_path or not os.path.exists(repo_path):
          raise ValueError(f"Repository path not found: {repo_path}")

      # Override default_branch if explicitly specified
      if inputs.target_branch:
          default_branch = inputs.target_branch

      # Get Jira URL from config
      jira_url = config.get("jira", {}).get("url", "https://issues.redhat.com")

      result = {
          "path": repo_path,
          "gitlab_project": gitlab_project or "automation-analytics/automation-analytics-backend",
          "default_branch": default_branch,
          "lint_command": repo_config.get("lint_command", "black --check . && flake8 ."),
          "jira_url": jira_url,
      }
    output: resolved_repo
  # ==================== PRE-FLIGHT CHECKS ====================

  # Step 0: Validate git repository state
  - name: validate_git_state
    description: "Check for rebase/merge in progress"
    compute: |
      import subprocess
      import os

      repo = resolved_repo["path"]

      # Get git dir
      result = subprocess.run(
          ["git", "rev-parse", "--git-dir"],
          cwd=repo,
          capture_output=True,
          text=True,
      )

      if result.returncode != 0:
          raise ValueError(f"Not a git repository: {repo}")

      git_dir = result.stdout.strip()
      if not git_dir.startswith("/"):
          git_dir = os.path.join(repo, git_dir)

      # Check for operations in progress
      if os.path.exists(os.path.join(git_dir, "rebase-merge")):
          raise ValueError(
              "Rebase in progress. Run 'git rebase --continue' or '--abort'"
          )
      if os.path.exists(os.path.join(git_dir, "MERGE_HEAD")):
          raise ValueError(
              "Merge in progress. Run 'git merge --continue' or '--abort'"
          )

      result = "Git state OK"
    output: git_state_check

  # Step 1: Get current branch and validate
  - name: get_current_branch
    description: "Get current branch name"
    compute: |
      import subprocess
      import os
      import re

      repo = resolved_repo["path"]

      result = subprocess.run(
          ["git", "rev-parse", "--abbrev-ref", "HEAD"],
          cwd=repo,
          capture_output=True,
          text=True,
      )

      if result.returncode != 0:
          raise ValueError(f"Not a git repository: {repo}")

      branch = result.stdout.strip()

      # Check for detached HEAD
      if branch == "HEAD":
          raise ValueError(
              "Detached HEAD state. Checkout a branch first: "
              "'git checkout -b <branch-name>'"
          )

      # Validate not on main/master
      if branch in ["main", "master"]:
          raise ValueError(
              "Cannot create MR from main/master. "
              "Create a feature branch first."
          )

      # Check if branch contains issue key
      issue_key = inputs.issue_key.upper()
      branch_has_key = issue_key in branch.upper()

      result = {
          "name": branch,
          "has_issue_key": branch_has_key,
          "issue_key": issue_key,
      }
    output: current_branch

  # Step 2: Check for uncommitted changes
  - name: check_uncommitted
    description: "Check for uncommitted changes"
    compute: |
      import subprocess
      import os

      repo = resolved_repo["path"]

      result = subprocess.run(
          ["git", "status", "--porcelain"],
          cwd=repo,
          capture_output=True,
          text=True,
      )

      uncommitted = result.stdout.strip()
      if uncommitted:
          files = uncommitted.split("\n")
          raise ValueError(
              f"Uncommitted changes detected ({len(files)} files). "
              "Please commit or stash before creating MR:\n"
              + "\n".join(files[:5])
          )

      result = "Clean working tree"
    output: uncommitted_check

  # Step 3: Validate commit messages
  - name: validate_commits
    description: "Check commit messages follow AAP-XXXXX convention"
    compute: |
      import subprocess
      import os
      import re

      repo = resolved_repo["path"]
      target = resolved_repo["default_branch"]
      issue_key = inputs.issue_key.upper()

      # Get commits not in target branch
      result = subprocess.run(
          ["git", "log", f"origin/{target}..HEAD", "--oneline"],
          cwd=repo,
          capture_output=True,
          text=True,
      )

      if result.returncode != 0:
          # Fetch and retry
          subprocess.run(["git", "fetch", "origin"], cwd=repo, capture_output=True)
          result = subprocess.run(
              ["git", "log", f"origin/{target}..HEAD", "--oneline"],
              cwd=repo,
              capture_output=True,
              text=True,
          )

      commits = result.stdout.strip().split("\n") if result.stdout.strip() else []

      if not commits:
          raise ValueError(
              f"No commits found ahead of origin/{target}. "
              "Make some commits first."
          )

      # Check each commit for issue key pattern
      bad_commits = []
      for commit in commits:
          if not re.search(r"AAP-\d+", commit, re.IGNORECASE):
              bad_commits.append(commit)

      warnings = []
      if bad_commits:
          warnings.append(
              f"⚠️ {len(bad_commits)} commit(s) missing AAP-XXXXX prefix"
          )

      result = {
          "count": len(commits),
          "commits": commits[:10],
          "bad_commits": bad_commits[:5],
          "warnings": warnings,
      }
    output: commit_validation

  # Step 4: Check for merge conflicts with target
  - name: check_mergeable
    description: "Check if branch can merge cleanly"
    compute: |
      import subprocess
      import os

      repo = resolved_repo["path"]
      target = resolved_repo["default_branch"]

      # Fetch latest
      subprocess.run(["git", "fetch", "origin", target], cwd=repo, capture_output=True)

      # Try merge --no-commit --no-ff to check for conflicts
      result = subprocess.run(
          ["git", "merge", "--no-commit", "--no-ff", f"origin/{target}"],
          cwd=repo,
          capture_output=True,
          text=True,
      )

      has_conflicts = result.returncode != 0
      conflict_info = result.stderr if has_conflicts else ""

      # Abort the merge attempt
      subprocess.run(["git", "merge", "--abort"], cwd=repo, capture_output=True)

      if has_conflicts:
          result = {
              "mergeable": False,
              "message": (
                  f"Branch has conflicts with {target}. "
                  "Run: skill_run(\"rebase_pr\", '{\"branch\": \""
                  + current_branch["name"]
                  + "\"}')"
              ),
          }
      else:
          result = {"mergeable": True, "message": "Branch can merge cleanly"}
    output: merge_check

  # Step 4b: Check for existing MR for this branch
  - name: check_existing_mr
    description: "Check if MR already exists for this branch"
    tool: gitlab_mr_list
    args:
      project: "{{ resolved_repo.gitlab_project }}"
      state: opened
    output: existing_mrs_raw
    on_error: continue

  - name: detect_duplicate_mr
    description: "Parse MRs to find duplicate"
    compute: |
      import re

      branch = current_branch["name"]
      existing_mrs_text = str(existing_mrs_raw) if existing_mrs_raw else ""

      # Look for this branch in existing MRs
      duplicate = None
      for line in existing_mrs_text.split("\n"):
          if branch.lower() in line.lower():
              # Extract MR ID
              match = re.search(r"!(\d+)", line)
              if match:
                  duplicate = {
                      "iid": match.group(1),
                      "line": line.strip()[:80],
                  }
                  break

      if duplicate:
          result = {
              "exists": True,
              "mr_iid": duplicate["iid"],
              "message": (
                  f"MR !{duplicate['iid']} already exists for branch '{branch}'. "
                  f"View it: gitlab_mr_view(project=\"{resolved_repo['gitlab_project']}\", "
                  f"mr_id={duplicate['iid']})"
              ),
          }
      else:
          result = {"exists": False, "message": "No existing MR found"}
    output: duplicate_check

  # ==================== LINTING ====================

  # Step 5a: Check if linting tools are available
  - name: check_lint_tools
    description: "Check if black and flake8 are installed"
    condition: "inputs.run_linting"
    compute: |
      import shutil

      missing = []
      if not shutil.which("black"):
          missing.append("black")
      if not shutil.which("flake8"):
          missing.append("flake8")

      if missing:
          result = {
              "available": False,
              "missing": missing,
              "message": f"Linting tools not installed: {missing}. Install with: pip install {' '.join(missing)}",
          }
      else:
          result = {"available": True, "missing": [], "message": "OK"}
    output: lint_tools_check

  # Step 5: Run black check
  - name: run_black
    description: "Run black formatter check"
    condition: "inputs.run_linting and (not lint_tools_check or lint_tools_check.get('available', True))"
    compute: |
      import subprocess
      import os

      repo = resolved_repo["path"]

      if inputs.auto_fix_lint:
          # Run black to fix
          result = subprocess.run(
              ["black", "."],
              cwd=repo,
              capture_output=True,
              text=True,
          )
          if result.returncode == 0:
              black_result = {"passed": True, "fixed": True, "message": "Black applied"}
          else:
              black_result = {
                  "passed": False,
                  "fixed": False,
                  "message": result.stderr[:200],
              }
      else:
          # Just check
          result = subprocess.run(
              ["black", "--check", "."],
              cwd=repo,
              capture_output=True,
              text=True,
          )
          if result.returncode == 0:
              black_result = {"passed": True, "message": "Black check passed"}
          else:
              # Count files that need formatting
              lines = result.stdout.strip().split("\n")
              files = [
                  ln
                  for ln in lines
                  if ln.startswith("would reformat") or ln.startswith("Oh no!")
              ]
              black_result = {
                  "passed": False,
                  "message": f"{len(files)} file(s) need formatting. "
                  "Run with auto_fix_lint=true or `black .`",
              }

      result = black_result
    output: black_result
    on_error: continue

  # Step 6: Run flake8 check
  - name: run_flake8
    description: "Run flake8 linting"
    condition: "inputs.run_linting"
    compute: |
      import subprocess
      import os

      repo = resolved_repo["path"]

      result = subprocess.run(
          [
              "flake8",
              "--max-line-length=100",
              "--ignore=E501,W503,E203",
              "--exclude=.git,__pycache__,migrations,venv,.venv",
              ".",
          ],
          cwd=repo,
          capture_output=True,
          text=True,
      )

      if result.returncode == 0:
          flake8_result = {"passed": True, "message": "Flake8 passed", "issues": []}
      else:
          issues = result.stdout.strip().split("\n")[:10]
          flake8_result = {
              "passed": False,
              "message": f"{len(issues)} flake8 issue(s)",
              "issues": issues,
          }

      result = flake8_result
    output: flake8_result
    on_error: continue

  # ==================== JIRA INTEGRATION ====================

  # Step 7: Get Jira issue details
  - name: get_issue
    description: "Fetch Jira issue details"
    tool: jira_view_issue
    args:
      issue_key: "{{ inputs.issue_key }}"
    output: issue
    on_error: continue

  # Step 8: Run Jira hygiene check
  - name: jira_hygiene_check
    description: "Check Jira issue quality"
    condition: "inputs.check_jira and issue"
    tool: skill_run
    args:
      skill_name: jira_hygiene
      inputs: '{"issue_key": "{{ inputs.issue_key }}", "auto_fix": true}'
    output: jira_check
    on_error: continue

  # ==================== CREATE MR ====================

  # Step 9: Push branch
  - name: push_branch
    description: "Push branch to origin"
    compute: |
      import subprocess
      import os

      repo = resolved_repo["path"]
      branch = current_branch["name"]

      result = subprocess.run(
          ["git", "push", "-u", "origin", branch],
          cwd=repo,
          capture_output=True,
          text=True,
      )

      if result.returncode != 0 and "already exists" not in result.stderr:
          # Try force push if rejected
          result = subprocess.run(
              ["git", "push", "-u", "origin", branch, "--force-with-lease"],
              cwd=repo,
              capture_output=True,
              text=True,
          )

      result = "Pushed to origin"
    output: push_result

  # Step 10: Build MR description
  - name: build_description
    description: "Build MR description with Jira link"
    compute: |
      import textwrap

      jira_url = resolved_repo.get("jira_url", "https://issues.redhat.com")
      issue_key = inputs.issue_key.upper()

      # Extract issue summary
      issue_text = str(issue) if issue else ""
      summary_match = issue_text[:100] if issue_text else "No description"

      # Build description
      description = textwrap.dedent(f"""
          ## Summary
          {summary_match}

          ## Jira
          [{issue_key}]({jira_url}/browse/{issue_key})

          ## Changes
          - Commits: {commit_validation.get("count", 0)}

          ## Testing
          - [ ] Unit tests pass
          - [ ] Integration tests pass
          - [ ] Manual testing completed

          ## Checklist
          - [ ] Code follows project conventions
          - [ ] Documentation updated if needed
          - [ ] No secrets or sensitive data
      """).strip()

      result = description
    output: mr_description

  # Step 11: Create the MR
  - name: create_mr
    description: "Create GitLab merge request"
    tool: gitlab_mr_create
    args:
      project: "{{ resolved_repo.gitlab_project }}"
      title: "{{ inputs.issue_key }} - {{ issue.summary[:50] if issue else 'Update' }}"
      description: "{{ mr_description }}"
      target_branch: "{{ resolved_repo.default_branch }}"
      source_branch: "{{ current_branch.name }}"
      draft: "{{ inputs.draft }}"
    output: mr

  # Step 12: Update Jira with MR link
  - name: update_jira
    description: "Add MR link to Jira issue"
    condition: "mr"
    tool: jira_add_comment
    args:
      issue_key: "{{ inputs.issue_key }}"
      comment: |
        MR created: {{ mr.web_url }}
        
        Branch: {{ current_branch.name }}
        Status: {{ "Draft" if inputs.draft else "Ready for Review" }}
    on_error: continue

  # Step 13: Update Jira status if not draft
  - name: update_status
    description: "Move Jira to In Review (if not draft)"
    condition: "not inputs.draft and mr"
    tool: jira_set_status
    args:
      issue_key: "{{ inputs.issue_key }}"
      status: "In Review"
    on_error: continue

  # Step 14: Emit MR created hook
  - name: emit_mr_created_hook
    description: "Notify team channel about new MR"
    condition: "mr and not inputs.draft"
    compute: |
      import asyncio
      import sys
      from pathlib import Path
      sys.path.insert(0, str(Path.home() / "src/redhat-ai-workflow"))
      
      try:
          from scripts.skill_hooks import emit_event
          
          asyncio.run(emit_event("mr_created", {
              "mr_id": str(mr.get('iid', '')),
              "issue_key": inputs.issue_key,
              "project": resolved_repo.get("gitlab_project", ""),
              "author": "",  # self - no need to DM
          }))
          result = "hook sent"
      except Exception as e:
          result = f"hook skipped: {e}"
    output: mr_hook_result
    on_error: continue

# ==================== OUTPUT ====================

outputs:
  - name: summary
    value: |
      ## {{ "✅" if mr else "❌" }} Merge Request {{ "Created" if mr else "Failed" }}
      
      {% if mr %}
      **MR:** {{ mr.title }}
      **URL:** {{ mr.web_url }}
      **Status:** {{ "Draft" if inputs.draft else "Ready for Review" }}
      **Branch:** `{{ current_branch.name }}` → `{{ resolved_repo.default_branch }}`
      **Project:** {{ resolved_repo.gitlab_project }}
      {% endif %}
      
      ---
      
      ### Pre-flight Checks
      
      | Check | Status |
      |-------|--------|
      | Uncommitted changes | ✅ Clean |
      | Commits | {{ commit_validation.count }} commit(s) |
      | Commit format | {{ "⚠️ " + commit_validation.warnings[0] if commit_validation.warnings else "✅ OK" }} |
      | Merge conflicts | {{ "❌ Has conflicts" if not merge_check.mergeable else "✅ Mergeable" }} |
      {% if inputs.run_linting %}
      | Black | {{ "✅ Passed" if black_result and black_result.passed else "⚠️ " + (black_result.message if black_result else "Skipped") }} |
      | Flake8 | {{ "✅ Passed" if flake8_result and flake8_result.passed else "⚠️ " + (flake8_result.message if flake8_result else "Skipped") }} |
      {% endif %}
      {% if inputs.check_jira %}
      | Jira hygiene | {{ "✅ Checked" if jira_check else "⚠️ Skipped" }} |
      {% endif %}
      
      {% if not merge_check.mergeable %}
      ---
      
      ### ⚠️ Action Required
      
      {{ merge_check.message }}
      {% endif %}
      
      {% if mr %}
      ---
      
      ### Next Steps
      {% if inputs.draft %}
      1. Complete your changes
      2. Push updates: `git push`
      3. Mark as ready: `gitlab_mr_update(project="...", mr_id={{ mr.iid }}, draft=false)`
      {% else %}
      1. Wait for pipeline to complete
      2. Request review from teammates
      3. Address feedback: `skill_run("check_my_prs", '{}')`
      {% endif %}
      {% endif %}

  - name: context
    value:
      mr_url: "{{ mr.web_url if mr else none }}"
      mr_id: "{{ mr.iid if mr else none }}"
      branch: "{{ current_branch.name }}"
      repo: "{{ resolved_repo.path }}"
      gitlab_project: "{{ resolved_repo.gitlab_project }}"
      mergeable: "{{ merge_check.mergeable }}"
      lint_passed: "{{ (black_result.passed if black_result else true) and (flake8_result.passed if flake8_result else true) }}"
