# Skill: Sync Branch with Main
# Quick rebase of current branch onto main

name: sync_branch
description: |
  Quickly sync current branch with main using rebase.
  
  Less aggressive than rebase_pr - good for ongoing work:
  - Fetches latest main
  - Rebases current branch onto main
  - Auto-resolves simple conflicts
  - Reports status
  
  If 'repo' is not provided, can be resolved from 'issue_key' or 'repo_name' via config.
  
  Use rebase_pr for MRs with merge commits that need cleanup.
version: "1.1"

inputs:
  - name: repo
    type: string
    required: false
    default: ""
    description: "Repository path - if not provided, resolved from issue_key or repo_name"

  - name: repo_name
    type: string
    required: false
    description: "Repository name from config (e.g., 'automation-analytics-backend')"

  - name: issue_key
    type: string
    required: false
    description: "Jira issue key - used to resolve repo if repo not specified"

  - name: base_branch
    type: string
    required: false
    default: ""
    description: "Branch to sync with (default: repo's default_branch from config)"

  - name: stash_changes
    type: boolean
    required: false
    default: true
    description: "Stash uncommitted changes before rebase"

  - name: force_push
    type: boolean
    required: false
    default: false
    description: "Force push after successful rebase"

steps:
  # ==================== RESOLVE REPOSITORY ====================

  - name: resolve_repo
    description: "Determine which repo to use"
    compute: |
      import json
      import os
      from pathlib import Path

      repo_path = None
      default_branch = "main"

      # Load config
      config_paths = [
          Path.cwd() / "config.json",
          Path.home() / "src/redhat-ai-workflow/config.json",
      ]
      config = {}
      for p in config_paths:
          if p.exists():
              with open(p) as f:
                  config = json.load(f)
              break

      repos = config.get("repositories", {})

      # Explicit repo path
      if inputs.repo and inputs.repo != "" and inputs.repo != ".":
          repo_path = inputs.repo
          for name, cfg in repos.items():
              if cfg.get("path") == repo_path:
                  default_branch = cfg.get("default_branch", "main")
                  break
      # Repo name from config
      elif inputs.repo_name and inputs.repo_name in repos:
          cfg = repos[inputs.repo_name]
          repo_path = cfg.get("path")
          default_branch = cfg.get("default_branch", "main")
      # Resolve from issue key
      elif inputs.issue_key:
          project_prefix = inputs.issue_key.split("-")[0].upper()
          for name, cfg in repos.items():
              if cfg.get("jira_project") == project_prefix:
                  repo_path = cfg.get("path")
                  default_branch = cfg.get("default_branch", "main")
                  break
      # Fall back to cwd
      else:
          cwd = os.getcwd()
          if os.path.exists(os.path.join(cwd, ".git")):
              repo_path = cwd
              for name, cfg in repos.items():
                  if cfg.get("path") == cwd:
                      default_branch = cfg.get("default_branch", "main")
                      break

      if not repo_path:
          raise ValueError("Repository not specified. Provide 'repo', 'repo_name', or 'issue_key'.")

      # Override default_branch if explicitly specified
      if inputs.base_branch:
          default_branch = inputs.base_branch

      result = {"path": repo_path, "default_branch": default_branch}
    output: resolved_repo

  # ==================== PRE-FLIGHT ====================

  - name: get_current_branch
    description: "Get current branch name"
    compute: |
      import subprocess
      import os

      repo = resolved_repo["path"]

      result = subprocess.run(
          ["git", "rev-parse", "--abbrev-ref", "HEAD"],
          cwd=repo,
          capture_output=True,
          text=True,
      )

      if result.returncode != 0:
          raise ValueError(f"Not a git repository: {repo}")

      branch = result.stdout.strip()

      if branch in ["main", "master"]:
          raise ValueError(
              f"Already on {branch}. "
              "Switch to a feature branch first."
          )

      result = branch
    output: current_branch

  - name: check_uncommitted
    description: "Check for uncommitted changes"
    compute: |
      import subprocess
      import os

      repo = resolved_repo["path"]

      result = subprocess.run(
          ["git", "status", "--porcelain"],
          cwd=repo,
          capture_output=True,
          text=True,
      )

      has_changes = bool(result.stdout.strip())
      change_count = len(result.stdout.strip().split("\n")) if has_changes else 0

      result = {"has_changes": has_changes, "count": change_count}
    output: uncommitted

  # ==================== STASH IF NEEDED ====================

  - name: stash_changes
    description: "Stash uncommitted changes"
    condition: "uncommitted.has_changes and inputs.stash_changes"
    compute: |
      import subprocess
      import os

      repo = resolved_repo["path"]

      result = subprocess.run(
          ["git", "stash", "push", "-m", f"sync_branch: auto-stash before rebase"],
          cwd=repo,
          capture_output=True,
          text=True,
      )

      if result.returncode != 0:
          raise ValueError(f"Failed to stash: {result.stderr}")

      result = "Stashed changes"
    output: stash_result

  # ==================== FETCH AND REBASE ====================

  - name: fetch_base
    description: "Fetch latest from remote"
    compute: |
      import subprocess
      import os

      repo = resolved_repo["path"]
      base = resolved_repo["default_branch"]

      result = subprocess.run(
          ["git", "fetch", "origin", base],
          cwd=repo,
          capture_output=True,
          text=True,
      )

      if result.returncode != 0:
          raise ValueError(f"Failed to fetch: {result.stderr}")

      result = f"Fetched origin/{base}"
    output: fetch_result

  - name: get_commits_behind
    description: "Check how many commits behind"
    compute: |
      import subprocess
      import os

      repo = resolved_repo["path"]
      base = resolved_repo["default_branch"]

      result = subprocess.run(
          ["git", "rev-list", "--count", f"HEAD..origin/{base}"],
          cwd=repo,
          capture_output=True,
          text=True,
      )

      behind = int(result.stdout.strip()) if result.returncode == 0 else 0

      result = subprocess.run(
          ["git", "rev-list", "--count", f"origin/{base}..HEAD"],
          cwd=repo,
          capture_output=True,
          text=True,
      )

      ahead = int(result.stdout.strip()) if result.returncode == 0 else 0

      result = {"behind": behind, "ahead": ahead}
    output: commit_status

  - name: rebase
    description: "Rebase onto base branch"
    condition: "commit_status.behind > 0"
    compute: |
      import subprocess
      import os

      repo = resolved_repo["path"]
      base = resolved_repo["default_branch"]

      result = subprocess.run(
          ["git", "rebase", f"origin/{base}"],
          cwd=repo,
          capture_output=True,
          text=True,
      )

      if result.returncode == 0:
          rebase_result = {
              "success": True,
              "conflicts": False,
              "message": f"Rebased onto origin/{base}",
          }
      else:
          # Check for conflicts
          status = subprocess.run(
              ["git", "status", "--porcelain"],
              cwd=repo,
              capture_output=True,
              text=True,
          )

          conflict_files = [
              ln[3:] for ln in status.stdout.split("\n")
              if ln.startswith("UU") or ln.startswith("AA")
          ]

          if conflict_files:
              rebase_result = {
                  "success": False,
                  "conflicts": True,
                  "conflict_files": conflict_files[:5],
                  "message": f"{len(conflict_files)} file(s) have conflicts",
              }
          else:
              rebase_result = {
                  "success": False,
                  "conflicts": False,
                  "message": result.stderr[:200],
              }

      result = rebase_result
    output: rebase_result

  - name: skip_rebase_up_to_date
    description: "Branch is already up to date"
    condition: "commit_status.behind == 0"
    compute: |
      result = {
          "success": True,
          "conflicts": False,
          "message": "Already up to date with main",
      }
    output: rebase_result

  # ==================== POP STASH ====================

  - name: pop_stash
    description: "Restore stashed changes"
    condition: "stash_result and rebase_result.success"
    compute: |
      import subprocess
      import os

      repo = resolved_repo["path"]

      result = subprocess.run(
          ["git", "stash", "pop"],
          cwd=repo,
          capture_output=True,
          text=True,
      )

      if result.returncode != 0:
          result = f"‚ö†Ô∏è Could not pop stash: {result.stderr[:100]}"
      else:
          result = "Restored stashed changes"
    output: pop_result
    on_error: continue

  # ==================== FORCE PUSH ====================

  - name: do_force_push
    description: "Force push rebased branch"
    condition: "rebase_result.success and inputs.force_push and commit_status.behind > 0"
    compute: |
      import subprocess
      import os

      repo = resolved_repo["path"]
      branch = current_branch

      result = subprocess.run(
          ["git", "push", "--force-with-lease", "origin", branch],
          cwd=repo,
          capture_output=True,
          text=True,
      )

      if result.returncode != 0:
          result = f"‚ö†Ô∏è Push failed: {result.stderr[:100]}"
      else:
          result = f"Force pushed {branch}"
    output: push_result
    on_error: continue

# ==================== OUTPUT ====================

outputs:
  - name: summary
    value: |
      ## üîÑ Sync Branch: `{{ current_branch }}`
      
      **Repo:** {{ resolved_repo.path }}
      **Base:** `{{ resolved_repo.default_branch }}`
      **Status:** {{ commit_status.behind }} behind, {{ commit_status.ahead }} ahead
      
      {% if commit_status.behind == 0 %}
      ‚úÖ Already up to date with `{{ resolved_repo.default_branch }}`
      {% elif rebase_result.success %}
      ‚úÖ Successfully rebased onto `{{ resolved_repo.default_branch }}`
      {% if stash_result %}
      - {{ stash_result }}
      - {{ pop_result if pop_result else "Changes restored" }}
      {% endif %}
      {% if push_result %}
      - {{ push_result }}
      {% else %}
      
      Ready to push:
      ```bash
      git push --force-with-lease origin {{ current_branch }}
      ```
      Or: `skill_run("sync_branch", '{"force_push": true}')`
      {% endif %}
      {% else %}
      
      {% if rebase_result.conflicts %}
      ‚ö†Ô∏è **Merge Conflicts Detected**
      
      Files with conflicts:
      {% for f in rebase_result.conflict_files %}
      - `{{ f }}`
      {% endfor %}
      
      **To resolve:**
      1. Edit each file (look for `<<<<<<<` markers)
      2. `git add <file>`
      3. `git rebase --continue`
      4. `git push --force-with-lease`
      
      **To abort:** `git rebase --abort`
      
      For auto-resolution, try: `skill_run("rebase_pr", '{"branch": "{{ current_branch }}"}')`
      {% else %}
      ‚ùå Rebase failed: {{ rebase_result.message }}
      {% endif %}
      {% endif %}

  - name: context
    value:
      branch: "{{ current_branch }}"
      repo: "{{ resolved_repo.path }}"
      base_branch: "{{ resolved_repo.default_branch }}"
      success: "{{ rebase_result.success }}"
      behind: "{{ commit_status.behind }}"
      ahead: "{{ commit_status.ahead }}"
      pushed: "{{ push_result is defined }}"


