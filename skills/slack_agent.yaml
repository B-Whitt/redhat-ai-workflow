# =============================================================================
# SLACK AGENT - Autonomous Slack Responder
# =============================================================================
# A meta-skill that processes incoming Slack messages, detects intent,
# and routes to appropriate skills/tools to take action and respond.
#
# Usage:
#   skill_run("slack_agent", '{}')                    # Process all pending
#   skill_run("slack_agent", '{"channel": "C123"}')   # Process specific channel
#   skill_run("slack_agent", '{"limit": 5}')          # Process up to 5 messages
#
# The agent can handle:
#   - Jira issue queries and updates
#   - PR/MR reviews and status checks
#   - Production debugging assistance
#   - Git operations guidance
#   - General development questions
# =============================================================================

name: slack_agent
description: |
  Autonomous Slack agent that processes incoming messages and takes action
  using existing skills and tools. Routes requests intelligently based on
  intent detection and provides formatted Slack responses.

version: "1.0.0"

inputs:
  - name: channel
    type: string
    required: false
    default: ""
    description: "Filter to specific channel (optional)"

  - name: limit
    type: integer
    required: false
    default: 10
    description: "Maximum messages to process"

  - name: dry_run
    type: boolean
    required: false
    default: false
    description: "Analyze but don't respond (for testing)"

  - name: auto_mark
    type: boolean
    required: false
    default: true
    description: "Automatically mark messages as processed"

constants:
  # Intent patterns for routing
  jira_patterns:
    - "AAP-\\d+"
    - "issue"
    - "jira"
    - "ticket"
    - "story"
    - "bug"
    - "epic"

  pr_patterns:
    - "!\\d+"
    - "MR"
    - "merge request"
    - "pull request"
    - "PR"
    - "review"
    - "pipeline"
    - "CI"

  prod_patterns:
    - "prod"
    - "production"
    - "alert"
    - "incident"
    - "outage"
    - "down"
    - "error"
    - "crash"

  git_patterns:
    - "branch"
    - "commit"
    - "merge"
    - "rebase"
    - "conflict"
    - "push"
    - "pull"

  help_patterns:
    - "help"
    - "how do i"
    - "what is"
    - "explain"
    - "guide"

  # Skill mappings
  skill_map:
    jira_query: jira_hygiene
    jira_status: close_issue
    pr_review: review_pr
    pr_status: check_my_prs
    prod_debug: debug_prod
    start_work: start_work
    create_mr: create_mr

steps:
  # ==================== FETCH PENDING MESSAGES ====================

  - name: get_pending_messages
    description: "Fetch messages waiting for agent processing"
    tool: slack_get_pending
    args:
      limit: "{{ inputs.limit }}"
      channel_id: "{{ inputs.channel }}"
    output: pending_result
    on_error: continue

  - name: parse_pending
    description: "Parse pending messages result"
    compute: |
      import json

      try:
          data = json.loads(pending_result) if isinstance(pending_result, str) else pending_result
          messages = data.get("messages", [])
          count = data.get("count", 0)
      except:
          messages = []
          count = 0

      result = {"messages": messages, "count": count}
    output: pending

  - name: check_empty
    description: "Check if there are messages to process"
    condition: "pending.count == 0"
    compute: |
      result = {
          "status": "idle",
          "message": "No pending messages to process",
          "processed": 0
      }
    output: empty_result

  # ==================== PROCESS EACH MESSAGE ====================

  - name: process_messages
    description: "Process each pending message"
    condition: "pending.count > 0"
    foreach: pending.messages
    do:
      # --- Intent Detection ---
      - name: detect_intent
        description: "Analyze message and detect intent"
        compute: |
          import re

          text = item.get("text", "").lower()
          original_text = item.get("text", "")
          user = item.get("user_name", "unknown")
          channel = item.get("channel_name", "unknown")
          is_mention = item.get("is_mention", False)
          is_dm = item.get("is_dm", False)

          # Extract key entities
          jira_keys = re.findall(r"AAP-\d+", original_text, re.IGNORECASE)
          mr_ids = re.findall(r"!(\d+)", original_text)

          # Determine primary intent
          intent = "general"
          confidence = 0.5
          entities = {}

          # Check for Jira-related intent
          if jira_keys:
              intent = "jira_query"
              confidence = 0.9
              entities["issue_keys"] = [k.upper() for k in jira_keys]
          elif any(p in text for p in ["jira", "issue", "ticket", "story", "bug"]):
              intent = "jira_search"
              confidence = 0.7

          # Check for PR/MR intent
          if mr_ids:
              intent = "pr_status"
              confidence = 0.9
              entities["mr_ids"] = mr_ids
          elif any(p in text for p in ["review", "merge request", "pull request", "mr", "pr"]):
              if "my" in text:
                  intent = "check_my_prs"
                  confidence = 0.8
              else:
                  intent = "pr_review"
                  confidence = 0.7

          # Check for production/incident intent
          if any(p in text for p in ["prod", "production", "alert", "incident", "outage", "down"]):
              intent = "prod_debug"
              confidence = 0.85

          # Check for work-starting intent
          if any(p in text for p in ["start work", "begin", "pick up", "work on"]) and jira_keys:
              intent = "start_work"
              confidence = 0.9

          # Check for help/guidance
          if any(p in text for p in ["help", "how do", "what is", "explain", "guide"]):
              intent = "help"
              confidence = 0.6

          # Check for standup request
          if "standup" in text or "status update" in text:
              intent = "standup"
              confidence = 0.8

          result = {
              "intent": intent,
              "confidence": confidence,
              "entities": entities,
              "text": original_text,
              "user": user,
              "channel": channel,
              "is_mention": is_mention,
              "is_dm": is_dm,
              "message_id": item.get("id", ""),
              "thread_ts": item.get("thread_ts"),
              "timestamp": item.get("timestamp", ""),
          }
        output: intent_analysis

      # --- Route to Appropriate Handler ---

      # Handler: Jira Query (specific issue)
      - name: handle_jira_query
        description: "Handle Jira issue query"
        condition: "intent_analysis.intent == 'jira_query' and intent_analysis.entities.get('issue_keys')"
        tool: jira_view_issue
        args:
          issue_key: "{{ intent_analysis.entities.issue_keys[0] }}"
        output: jira_result
        on_error: continue

      - name: format_jira_response
        condition: "intent_analysis.intent == 'jira_query' and jira_result"
        compute: |
          issue = jira_result if jira_result else "Issue not found"
          key = intent_analysis["entities"]["issue_keys"][0]

          # Format for Slack
          response = f"üìã *{key}*\n\n{issue[:1500]}"

          if len(str(issue)) > 1500:
              response += "\n\n_...truncated. View full issue in Jira._"

          result = {"response": response, "success": True}
        output: jira_response

      # Handler: Check My PRs
      - name: handle_check_my_prs
        description: "Check user's open PRs"
        condition: "intent_analysis.intent == 'check_my_prs'"
        tool: skill_run
        args:
          skill_name: check_my_prs
          inputs: '{"dry_run": true}'
        output: my_prs_result
        on_error: continue

      - name: format_my_prs_response
        condition: "intent_analysis.intent == 'check_my_prs' and my_prs_result"
        compute: |
          import json

          try:
              data = json.loads(my_prs_result) if isinstance(my_prs_result, str) else my_prs_result
              response = f"üîç *Your Open MRs*\n\n{str(data)[:1500]}"
          except:
              response = f"üìù PR check result:\n{str(my_prs_result)[:1500]}"

          result = {"response": response, "success": True}
        output: my_prs_response

      # Handler: PR Status (specific MR)
      - name: handle_pr_status
        description: "Get specific MR status"
        condition: "intent_analysis.intent == 'pr_status' and intent_analysis.entities.get('mr_ids')"
        tool: gitlab_mr_view
        args:
          project: "{{ constants.gitlab_project | default('automation-analytics/automation-analytics-backend') }}"
          mr_id: "{{ intent_analysis.entities.mr_ids[0] }}"
        output: mr_result
        on_error: continue

      - name: format_mr_response
        condition: "intent_analysis.intent == 'pr_status' and mr_result"
        compute: |
          mr_id = intent_analysis["entities"]["mr_ids"][0]
          response = f"ü¶ä *MR !{mr_id}*\n\n{str(mr_result)[:1500]}"
          result = {"response": response, "success": True}
        output: mr_response

      # Handler: Production Debug
      - name: handle_prod_debug
        description: "Handle production debugging request"
        condition: "intent_analysis.intent == 'prod_debug'"
        compute: |
          # Don't automatically run debug_prod from Slack - too risky
          # Instead, provide guidance and offer to help

          response = """üö® *Production Issue Detected*

          I can help investigate! Here's what I can check:
          ‚Ä¢ Pod status and recent events
          ‚Ä¢ Recent deployments
          ‚Ä¢ Prometheus alerts
          ‚Ä¢ Application logs

          To start investigation, reply with:
          ‚Ä¢ `debug tower-analytics-prod` - Check main namespace
          ‚Ä¢ `debug tower-analytics-prod-billing` - Check billing namespace

          Or provide more context about the issue."""

          result = {"response": response, "success": True, "needs_confirmation": True}
        output: prod_response

      # Handler: Start Work
      - name: handle_start_work
        description: "Handle start work request"
        condition: "intent_analysis.intent == 'start_work' and intent_analysis.entities.get('issue_keys')"
        compute: |
          key = intent_analysis["entities"]["issue_keys"][0]

          response = f"""üöÄ *Ready to Start Work on {key}*

          I'll help you get set up! This will:
          1. Fetch issue details from Jira
          2. Create/checkout a branch
          3. Update issue status to In Progress

          Reply with:
          ‚Ä¢ `yes, start {key}` - to proceed
          ‚Ä¢ `just branch {key}` - create branch only
          ‚Ä¢ `info {key}` - show issue details first"""

          result = {"response": response, "success": True, "needs_confirmation": True}
        output: start_work_response

      # Handler: Help/General
      - name: handle_help
        description: "Handle help requests"
        condition: "intent_analysis.intent == 'help'"
        compute: |
          text = intent_analysis["text"].lower()

          if "jira" in text:
              response = """üìã *Jira Help*

              I can help with Jira! Try:
              ‚Ä¢ `AAP-12345` - View issue details
              ‚Ä¢ `my issues` - List your assigned issues
              ‚Ä¢ `search AAP project priority=High` - Search issues
              ‚Ä¢ `create story "Title here"` - Create new story"""

          elif "mr" in text or "pr" in text or "review" in text:
              response = """ü¶ä *GitLab MR Help*

              I can help with MRs! Try:
              ‚Ä¢ `!123` - View MR details
              ‚Ä¢ `my MRs` - Check your open MRs
              ‚Ä¢ `review !123` - Review an MR
              ‚Ä¢ `pipeline !123` - Check pipeline status"""

          elif "git" in text:
              response = """üìÇ *Git Help*

              I can help with Git! Try:
              ‚Ä¢ `start AAP-12345` - Create branch from issue
              ‚Ä¢ `sync branch` - Rebase onto main
              ‚Ä¢ `rebase !123` - Rebase an MR
              ‚Ä¢ `what branch am I on` - Check current branch"""

          else:
              response = """üëã *Hey there! I'm your AI assistant.*

              Here's what I can help with:

              üìã *Jira*: `AAP-12345`, `my issues`, `create story`
              ü¶ä *GitLab*: `!123`, `my MRs`, `review !123`
              üìÇ *Git*: `start AAP-12345`, `sync branch`
              üöÄ *Deploy*: `release status`, `deploy check`
              üö® *Incidents*: `prod status`, `check alerts`

              Just mention me with your request!"""

          result = {"response": response, "success": True}
        output: help_response

      # Handler: Standup
      - name: handle_standup
        description: "Generate standup summary"
        condition: "intent_analysis.intent == 'standup'"
        tool: skill_run
        args:
          skill_name: standup_summary
          inputs: '{"days": 1}'
        output: standup_result
        on_error: continue

      - name: format_standup_response
        condition: "intent_analysis.intent == 'standup' and standup_result"
        compute: |
          import json

          try:
              data = json.loads(standup_result) if isinstance(standup_result, str) else standup_result
              response = f"üìä *Daily Standup*\n\n{str(data)[:1500]}"
          except:
              response = f"üìä *Standup Summary*\n\n{str(standup_result)[:1500]}"

          result = {"response": response, "success": True}
        output: standup_response

      # Handler: General/Unknown
      - name: handle_general
        description: "Handle general or unknown requests"
        condition: "intent_analysis.intent == 'general'"
        compute: |
          text = intent_analysis["text"]
          user = intent_analysis["user"]

          response = f"""üëã Hi {user}!

          I received your message but I'm not sure what action to take:
          > {text[:200]}{"..." if len(text) > 200 else ""}

          Could you clarify? For example:
          ‚Ä¢ Include a Jira issue key (AAP-12345)
          ‚Ä¢ Include an MR number (!123)
          ‚Ä¢ Ask for help: "help with git"

          Or just say `help` for a full list of commands!"""

          result = {"response": response, "success": True}
        output: general_response

      # --- Collect Response ---
      - name: collect_response
        description: "Collect the appropriate response"
        compute: |
          # Find which handler produced a response
          responses = [
              jira_response if 'jira_response' in dir() else None,
              my_prs_response if 'my_prs_response' in dir() else None,
              mr_response if 'mr_response' in dir() else None,
              prod_response if 'prod_response' in dir() else None,
              start_work_response if 'start_work_response' in dir() else None,
              help_response if 'help_response' in dir() else None,
              standup_response if 'standup_response' in dir() else None,
              general_response if 'general_response' in dir() else None,
          ]

          # Get first non-None response
          response_data = None
          for r in responses:
              if r and isinstance(r, dict) and r.get("response"):
                  response_data = r
                  break

          if not response_data:
              response_data = {
                  "response": "I encountered an issue processing your request. Please try again or say `help` for guidance.",
                  "success": False
              }

          result = {
              "intent": intent_analysis["intent"],
              "confidence": intent_analysis["confidence"],
              "message_id": intent_analysis["message_id"],
              "channel": intent_analysis["channel"],
              "user": intent_analysis["user"],
              "response": response_data["response"],
              "success": response_data.get("success", False),
              "needs_confirmation": response_data.get("needs_confirmation", False),
          }
        output: collected_response

      # --- Send Response (if not dry run) ---
      - name: send_response
        description: "Send response back to Slack"
        condition: "not inputs.dry_run and collected_response.success"
        tool: slack_send_message
        args:
          channel_id: "{{ item.channel_id }}"
          text: "{{ collected_response.response }}"
          thread_ts: "{{ item.thread_ts or item.timestamp }}"
        output: send_result
        on_error: continue

      # --- Mark as Processed ---
      - name: mark_processed
        description: "Mark message as processed"
        condition: "inputs.auto_mark and collected_response.success and not inputs.dry_run"
        tool: slack_mark_processed
        args:
          message_id: "{{ collected_response.message_id }}"
        output: mark_result
        on_error: continue

    output: processed_messages

  # ==================== SUMMARY ====================

  - name: generate_summary
    description: "Generate processing summary"
    compute: |
      if pending.count == 0:
          result = empty_result if 'empty_result' in dir() else {
              "status": "idle",
              "message": "No pending messages",
              "processed": 0
          }
      else:
          messages = processed_messages if 'processed_messages' in dir() else []
          successful = sum(1 for m in messages if m.get("success", False))
          failed = len(messages) - successful

          result = {
              "status": "completed",
              "total_pending": pending.count,
              "processed": len(messages),
              "successful": successful,
              "failed": failed,
              "dry_run": inputs.dry_run,
              "details": messages,
          }
    output: summary

outputs:
  - name: result
    value: "{{ summary }}"

  - name: report
    value: |
      ## ü§ñ Slack Agent Report

      {% if summary.status == 'idle' %}
      *No pending messages to process.*
      {% else %}
      **Processed:** {{ summary.processed }} messages
      **Successful:** {{ summary.successful }}
      **Failed:** {{ summary.failed }}
      {% if summary.dry_run %}*(Dry run - no responses sent)*{% endif %}

      {% if summary.details %}
      ### Message Details
      {% for msg in summary.details %}
      - **{{ msg.user }}** in #{{ msg.channel }}: {{ msg.intent }} ({{ (msg.confidence * 100)|int }}% confidence)
        {% if msg.success %}‚úÖ{% else %}‚ùå{% endif %}
      {% endfor %}
      {% endif %}
      {% endif %}

