# Monitor Jira Comments Skill
# Scheduled skill that runs daily to check active sprint issues for new comments.
# Detects questions from other users and responds to them.
#
# This skill:
# 1. Searches for sprint issues assigned to the current user
# 2. Checks each issue for recent comments
# 3. Detects questions that need responses
# 4. Responds naturally (no bot language)
# 5. Notifies user via Slack of any interactions

name: monitor_jira_comments
description: |
  Daily monitoring of Jira comments on sprint issues.

  Detects questions from team members and responds appropriately.
  All responses are written in natural language - never mentions "bot" or "automated".

  Scheduled to run at 9 AM on weekdays via cron.

version: "1.0"

links:
  depends_on: []            # Standalone scheduled skill
  validates: []             # Monitoring doesn't validate other skills
  validated_by: []          # Scheduled job, not validated by others
  chains_to:
    - start_work            # Detected question may need work
    - notify_team           # Notify about important comments
  provides_context_for:
    - coffee                # Morning briefing shows comment activity
    - standup_summary       # Comment responses appear in standup

inputs:
  - name: jira_project
    description: Jira project key (e.g., AAP)
    default: "AAP"
  - name: hours_lookback
    description: How many hours back to check for new comments
    default: 24
  - name: notify_user
    description: Whether to notify user via Slack
    default: true
  - name: slack_channel
    description: Slack channel for notifications
    default: ""
  - name: dry_run
    description: If true, don't post responses, just report what would be done
    default: false

outputs:
  - name: issues_checked
    description: Number of issues checked
  - name: questions_found
    description: Number of questions detected
  - name: responses_sent
    description: Number of responses sent
  - name: notifications_sent
    description: Number of Slack notifications sent

steps:
  - name: load_developer_persona
    description: Ensure developer persona is loaded
    tool: persona_load
    args:
      persona_name: "developer"

  - name: search_sprint_issues
    description: Find all sprint issues assigned to current user
    tool: jira_search
    args:
      jql: "project = {{ inputs.jira_project }} AND Sprint in openSprints() AND assignee = currentUser() ORDER BY updated DESC"
      max_results: 50

  - name: parse_issues
    description: Parse the search results into a list
    compute: |
      import json

      result_text = str(search_sprint_issues)
      issues = []

      # Try to parse as JSON if possible
      try:
          # Look for issue keys in the result
          import re
          keys = re.findall(r'[A-Z]+-\d+', result_text)
          issues = list(set(keys))  # Deduplicate
      except Exception:
          pass

      result = {"issues": issues, "count": len(issues)}

  - name: process_all_issues
    description: Iterate over all issues, check comments, respond to questions, and notify
    condition: "{{ parse_issues.count > 0 }}"
    compute: |
      import re
      from datetime import datetime, timedelta
      import json

      issues = parse_issues.get("issues", [])
      hours_lookback = int(inputs.get("hours_lookback", 24))
      dry_run = inputs.get("dry_run", False)
      notify_user = inputs.get("notify_user", True)
      slack_channel = inputs.get("slack_channel", "") or "team-automation-analytics"

      # Question detection patterns
      question_patterns = [
          r'\?',
          r'(?i)can you',
          r'(?i)could you',
          r'(?i)would you',
          r'(?i)please clarify',
          r'(?i)what about',
          r'(?i)how do',
          r'(?i)when will',
          r'(?i)any update',
          r'(?i)status on',
          r'(?i)thoughts on',
          r'(?i)feedback',
      ]

      # Phrases that indicate our own comments (skip these)
      own_comment_phrases = [
          'merge request ready',
          'changes address',
          'please review',
          "i'm reviewing",
          'working on',
      ]

      questions_found = 0
      responses_sent = 0
      notifications_sent = 0

      for issue_key in issues:
          # Get issue details via nested skill runner calling jira_view_issue
          view_result = run_skill("jira_view_issue_wrapper", {"issue_key": issue_key})
          # Fallback: use memory_ask to get issue info if wrapper doesn't exist
          if not view_result.get("success"):
              # Try direct approach - skip this issue if we can't fetch it
              continue

          issue_text = str(view_result.get("result", ""))

          # Parse comments from issue text
          comments = []
          lines = issue_text.split('\n')
          in_comments = False
          current_comment = []

          for line in lines:
              if 'comment' in line.lower() and ':' in line:
                  in_comments = True
                  if current_comment:
                      comments.append('\n'.join(current_comment))
                  current_comment = [line]
              elif in_comments:
                  current_comment.append(line)

          if current_comment:
              comments.append('\n'.join(current_comment))

          # Detect questions in comments
          questions = []
          for comment in comments:
              for pattern in question_patterns:
                  if re.search(pattern, comment):
                      if not any(phrase in comment.lower() for phrase in own_comment_phrases):
                          questions.append({
                              "text": comment[:200],
                              "pattern_matched": pattern,
                          })
                      break

          if not questions:
              continue

          questions_found += len(questions)

          # Generate response based on question types
          responses = []
          for q in questions:
              question_text = q.get("text", "").lower()

              if "status" in question_text or "update" in question_text:
                  responses.append(
                      "Thanks for checking in! I'm actively working on this and making good progress. "
                      "I'll have an update soon with more details on the implementation."
                  )
              elif "clarify" in question_text or "explain" in question_text:
                  responses.append(
                      "Good question - let me clarify. I'll add more context to the description "
                      "and follow up with specific details shortly."
                  )
              elif "when" in question_text or "timeline" in question_text:
                  responses.append(
                      "I'm targeting to have this ready for review soon. "
                      "I'll update the issue with a more specific timeline once I've completed the initial implementation."
                  )
              elif "feedback" in question_text or "thoughts" in question_text:
                  responses.append(
                      "Thanks for the input! I'll review and incorporate your feedback. "
                      "Let me take a closer look and get back to you."
                  )
              else:
                  responses.append(
                      "Thanks for reaching out! I've seen your message and will respond with more details shortly."
                  )

          if len(responses) > 1:
              final_response = "Thanks for the questions!\n\n" + "\n\n".join(responses)
          elif responses:
              final_response = responses[0]
          else:
              final_response = ""

          # Post response to Jira (unless dry run)
          if final_response and not dry_run:
              post_result = run_skill("jira_add_comment_wrapper", {
                  "issue_key": issue_key,
                  "comment": final_response,
              })
              if post_result.get("success"):
                  responses_sent += 1

          # Notify user via Slack
          if notify_user:
              action_label = "responded automatically" if not dry_run else "dry run"
              notify_result = run_skill("notify_team", {
                  "message": f"New question on {issue_key} - {action_label}",
                  "channel": slack_channel,
                  "type": "info",
                  "context": f"View issue: https://issues.redhat.com/browse/{issue_key}",
              })
              if notify_result.get("success"):
                  notifications_sent += 1

          # Log interaction to memory
          current_timestamp = datetime.now().isoformat()
          memory.append_to_list(
              "state/sprint_timeline",
              issue_key,
              {
                  "timestamp": current_timestamp,
                  "action": "comment_response",
                  "description": f"Responded to {len(questions)} question(s)",
              },
          )

      result = {
          "issues_checked": len(issues),
          "questions_found": questions_found,
          "responses_sent": responses_sent,
          "notifications_sent": notifications_sent,
      }
    output: loop_results

  - name: compile_summary
    description: Compile summary of all checks
    compute: |
      issues_checked = parse_issues.get("count", 0)

      if 'loop_results' in dir() and loop_results:
          questions_found = loop_results.get("questions_found", 0)
          responses_sent = loop_results.get("responses_sent", 0)
          notifications_sent = loop_results.get("notifications_sent", 0)
      else:
          questions_found = 0
          responses_sent = 0
          notifications_sent = 0

      result = {
          "issues_checked": issues_checked,
          "questions_found": questions_found,
          "responses_sent": responses_sent,
          "notifications_sent": notifications_sent,
          "summary": f"Checked {issues_checked} issues, found {questions_found} questions"
      }

  - name: log_monitoring_run
    description: Log this monitoring run to session
    tool: memory_session_log
    args:
      action: "jira_comment_monitoring"
      details: "{{ compile_summary.summary }}"
