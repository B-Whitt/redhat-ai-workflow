# Skill: Start Work on Jira Issue
# Combines issue lookup, branch creation/checkout, MR feedback, and status update

name: start_work
description: |
  Begin or resume working on a Jira issue.
  
  If 'repo' is not provided, automatically resolves the repository from the
  issue key prefix (e.g., AAP â†’ automation-analytics-backend) using config.json.
  
  Features:
  - Gets issue context from Jira
  - Creates or checks out feature branch
  - Shows MR feedback if exists
  - Updates Jira status
version: "1.3"

inputs:
  - name: issue_key
    type: string
    required: true
    description: "Jira issue key (e.g., AAP-12345)"
  - name: repo
    type: string
    required: false
    default: ""
    description: "Repository path - if not provided, resolved from issue key via config"
  - name: repo_name
    type: string
    required: false
    description: "Repository name from config (e.g., 'automation-analytics-backend') - alternative to repo path"

steps:
  # ==================== RESOLVE REPOSITORY ====================

  # Step 0: Resolve repository from issue key if not provided
  - name: resolve_repo
    description: "Determine which repo to use based on issue key or explicit input"
    compute: |
      import json
      import os
      from pathlib import Path

      # Explicit repo path takes priority
      if inputs.repo and inputs.repo != "" and inputs.repo != ".":
          repo_path = inputs.repo
          repo_source = "explicit"
      # Then repo name from config
      elif inputs.repo_name:
          config_paths = [
              Path.cwd() / "config.json",
              Path.home() / "src/redhat-ai-workflow/config.json",
          ]
          config = {}
          for p in config_paths:
              if p.exists():
                  with open(p) as f:
                      config = json.load(f)
                  break
          
          repos = config.get("repositories", {})
          if inputs.repo_name in repos:
              repo_path = repos[inputs.repo_name].get("path", "")
              repo_source = "config_name"
          else:
              raise ValueError(f"Repository '{inputs.repo_name}' not found in config.json")
      # Finally, try to resolve from issue key prefix
      else:
          # Load config
          config_paths = [
              Path.cwd() / "config.json",
              Path.home() / "src/redhat-ai-workflow/config.json",
          ]
          config = {}
          for p in config_paths:
              if p.exists():
                  with open(p) as f:
                      config = json.load(f)
                  break
          
          repos = config.get("repositories", {})
          project_prefix = inputs.issue_key.split("-")[0].upper()
          
          # Find repos matching this Jira project
          matching = []
          for name, cfg in repos.items():
              if cfg.get("jira_project") == project_prefix:
                  matching.append({"name": name, "path": cfg.get("path"), "gitlab": cfg.get("gitlab")})
          
          if len(matching) == 0:
              # Fall back to cwd if we're in a git repo
              cwd = os.getcwd()
              git_check = os.path.exists(os.path.join(cwd, ".git"))
              if git_check:
                  repo_path = cwd
                  repo_source = "cwd_fallback"
              else:
                  raise ValueError(
                      f"No repository configured for {project_prefix} issues. "
                      "Please specify 'repo' or 'repo_name', or run from within a git repository."
                  )
          elif len(matching) == 1:
              repo_path = matching[0]["path"]
              repo_source = "issue_key"
          else:
              # Multiple matches - need clarification
              names = ", ".join(m["name"] for m in matching)
              raise ValueError(
                  f"Multiple repositories match {project_prefix} issues: {names}. "
                  "Please specify 'repo_name' to choose one."
              )
      
      if not repo_path or not os.path.exists(repo_path):
          raise ValueError(f"Repository path not found: {repo_path}")
      
      result = {"path": repo_path, "source": repo_source}
    output: resolved_repo

  # ==================== PRE-FLIGHT VALIDATION ====================

  # Step 0a: Validate git repository
  - name: validate_git_repo
    description: "Ensure we're in a valid git repository"
    compute: |
      import subprocess
      import os

      repo = resolved_repo["path"]

      # Check if git repo
      result = subprocess.run(
          ["git", "rev-parse", "--git-dir"],
          cwd=repo,
          capture_output=True,
          text=True,
      )

      if result.returncode != 0:
          raise ValueError(f"Not a git repository: {repo}")

      git_dir = result.stdout.strip()
      if not git_dir.startswith("/"):
          git_dir = os.path.join(repo, git_dir)

      # Check for rebase/merge in progress
      issues = []
      if os.path.exists(os.path.join(git_dir, "rebase-merge")):
          issues.append("rebase in progress - run 'git rebase --continue' or '--abort'")
      if os.path.exists(os.path.join(git_dir, "MERGE_HEAD")):
          issues.append("merge in progress - run 'git merge --continue' or '--abort'")

      if issues:
          raise ValueError(f"Git operation in progress: {issues[0]}")

      result = {"valid": True, "repo": repo}
    output: git_validation

  # Step 0b: Validate Jira issue key format
  - name: validate_issue_key
    description: "Validate issue key format"
    compute: |
      import re

      key = inputs.issue_key.upper().strip()

      if not re.match(r"^[A-Z]+-\d+$", key):
          raise ValueError(
              f"Invalid issue key format: {inputs.issue_key}. "
              "Expected format: AAP-12345"
          )

      result = key
    output: validated_issue_key

  # Step 1: Get issue details
  - name: get_issue
    tool: jira_view_issue
    args:
      issue_key: "{{ validated_issue_key }}"
    output: issue
    on_error: continue

  - name: check_issue_exists
    description: "Verify issue was found"
    compute: |
      if not issue or "not found" in str(issue).lower():
          raise ValueError(
              f"Jira issue {validated_issue_key} not found. "
              "Check the issue key and try again."
          )
      result = "Issue found"
    output: issue_check

  # Step 2: Fetch latest and check for existing branch
  - name: check_existing_branch
    description: "Check if branch for this issue already exists"
    compute: |
      import subprocess
      import re
      import os
      
      repo_path = resolved_repo["path"]
      issue_key = inputs.issue_key.upper()
      
      # Fetch all remotes
      subprocess.run(["git", "fetch", "--all", "--prune"], cwd=repo_path, capture_output=True)
      
      # List all branches (local and remote)
      result = subprocess.run(
        ["git", "branch", "-a"],
        cwd=repo_path,
        capture_output=True,
        text=True
      )
      
      branches = result.stdout.strip().split('\n')
      
      # Look for branches containing this issue key
      matching = []
      for branch in branches:
        branch = branch.strip().replace('* ', '')
        if issue_key in branch.upper():
          clean_name = branch.replace('remotes/origin/', '')
          if clean_name not in matching:
            matching.append(clean_name)
      
      if matching:
        existing_branch = matching[0]
        result = {"exists": True, "branch": existing_branch, "all_matches": matching}
      else:
        result = {"exists": False, "branch": None, "all_matches": []}
    output: branch_check

  # Step 3: If branch exists, check for MR
  - name: check_existing_mr
    description: "Check if there's an open MR for this branch"
    condition: "{{ branch_check.get('exists', False) }}"
    compute: |
      import subprocess
      import os
      import re
      
      repo_path = resolved_repo["path"]
      branch = branch_check['branch']
      issue_key = inputs.issue_key.upper()
      
      # Use glab to list MRs
      result = subprocess.run(
        ["glab", "mr", "list", "--state=opened"],
        cwd=repo_path,
        capture_output=True,
        text=True
      )
      
      mr_info = None
      if result.returncode == 0:
        for line in result.stdout.split('\n'):
          # Check if this MR matches our issue key or branch
          if issue_key in line.upper() or branch in line:
            # Extract MR ID (usually first number in the line)
            match = re.search(r'!(\d+)', line)
            if match:
              mr_id = match.group(1)
              mr_info = {"id": mr_id, "line": line.strip()}
              break
      
      result = mr_info
    output: existing_mr
    on_error: continue

  # Step 4: If MR exists, get comments/feedback
  - name: get_mr_feedback
    description: "Get review comments from MR"
    condition: "{{ existing_mr and existing_mr.get('id') }}"
    compute: |
      import subprocess
      import os
      
      repo_path = resolved_repo["path"]
      mr_id = existing_mr['id']
      
      # Get MR details
      result = subprocess.run(
        ["glab", "mr", "view", mr_id],
        cwd=repo_path,
        capture_output=True,
        text=True
      )
      
      mr_details = result.stdout if result.returncode == 0 else ""
      
      # Get MR notes/comments
      notes_result = subprocess.run(
        ["glab", "mr", "note", "list", mr_id],
        cwd=repo_path,
        capture_output=True,
        text=True
      )
      
      comments = notes_result.stdout if notes_result.returncode == 0 else ""
      
      # Check pipeline status
      pipeline_result = subprocess.run(
        ["glab", "ci", "status"],
        cwd=repo_path,
        capture_output=True,
        text=True
      )
      
      pipeline_status = pipeline_result.stdout.strip() if pipeline_result.returncode == 0 else "unknown"
      
      # Determine if there's actionable feedback
      has_feedback = bool(comments.strip()) and "No notes found" not in comments
      
      result = {
        "mr_id": mr_id,
        "details": mr_details[:1000] if mr_details else "",
        "comments": comments[:1500] if comments else "",
        "has_feedback": has_feedback,
        "pipeline": pipeline_status[:200]
      }
    output: mr_feedback
    on_error: continue

  # Step 5: Check Jira for recent updates/comments
  - name: check_jira_updates
    description: "Check for recent Jira comments or status changes"
    condition: "{{ branch_check.get('exists', False) }}"
    compute: |
      import subprocess
      
      # Get full issue details with comments
      result = subprocess.run(
        ["rh-issue", "view-issue", inputs.issue_key, "--output", "json"],
        capture_output=True,
        text=True
      )
      
      jira_updates = None
      if result.returncode == 0:
        try:
          import json
          data = json.loads(result.stdout)
          comments = data.get('comments', [])
          # Get last 3 comments
          recent_comments = comments[-3:] if comments else []
          jira_updates = {
            "status": data.get('status', 'Unknown'),
            "recent_comments": recent_comments,
            "has_updates": len(recent_comments) > 0
          }
        except:
          jira_updates = {"status": "Unknown", "recent_comments": [], "has_updates": False}
      else:
        jira_updates = {"status": "Unknown", "recent_comments": [], "has_updates": False}
      
      result = jira_updates
    output: jira_updates
    on_error: continue

  # Step 6: Generate branch name (only used if creating new)
  - name: create_branch_name
    condition: "{{ not branch_check.get('exists', False) }}"
    compute: |
      import re
      key = inputs.issue_key.upper()
      # Extract summary from issue output
      issue_text = str(issue)
      summary = issue_text[:40].lower()
      summary = re.sub(r'[^a-z0-9]+', '-', summary).strip('-')
      branch_name = f"{key}-{summary}"
    output: new_branch_name

  # Step 7a: Checkout existing branch
  - name: checkout_existing
    description: "Checkout existing branch for this issue"
    condition: "{{ branch_check.get('exists', False) }}"
    compute: |
      import subprocess
      import os
      
      repo_path = resolved_repo["path"]
      branch = branch_check['branch']
      
      result = subprocess.run(
        ["git", "checkout", branch],
        cwd=repo_path,
        capture_output=True,
        text=True
      )
      
      if result.returncode != 0:
        subprocess.run(
          ["git", "checkout", "-b", branch, f"origin/{branch}"],
          cwd=repo_path,
          capture_output=True
        )
      
      subprocess.run(["git", "pull", "--rebase"], cwd=repo_path, capture_output=True)
      
      result = f"Checked out: {branch}"
    output: checkout_result

  # Step 7b: Create new branch
  - name: setup_new_branch
    description: "Switch to main, pull, create new branch"
    condition: "{{ not branch_check.get('exists', False) }}"
    compute: |
      import subprocess
      import os
      
      repo_path = resolved_repo["path"]
      branch_name = new_branch_name
      
      subprocess.run(["git", "checkout", "main"], cwd=repo_path, capture_output=True)
      subprocess.run(["git", "pull", "--rebase"], cwd=repo_path, capture_output=True)
      
      result = subprocess.run(
        ["git", "checkout", "-b", branch_name],
        cwd=repo_path,
        capture_output=True,
        text=True
      )
      
      if result.returncode == 0:
        result = f"Created: {branch_name}"
      else:
        result = f"Failed: {result.stderr}"
    output: create_result

  # Step 8: Update Jira status (only for new work)
  - name: update_status
    condition: "{{ not branch_check.get('exists', False) }}"
    tool: jira_set_status
    args:
      issue_key: "{{ inputs.issue_key }}"
      status: "In Progress"
    on_error: continue

  # Step 9: Determine final branch name
  - name: get_final_branch
    compute: |
      if branch_check.get('exists', False):
        result = branch_check['branch']
      else:
        result = new_branch_name
    output: final_branch

outputs:
  - name: summary
    value: |
      ## {{ "ðŸ“‚ Resuming" if branch_check.exists else "âœ¨ Starting" }} Work on {{ inputs.issue_key }}
      
      **Issue:** {{ issue }}
      **Branch:** `{{ final_branch }}`
      {% if branch_check.exists %}
      
      ---
      {% if mr_feedback and mr_feedback.has_feedback %}
      
      ### ðŸ’¬ MR Feedback ({{ mr_feedback.mr_id }})
      
      There are review comments on your MR:
      
      ```
      {{ mr_feedback.comments[:800] }}
      ```
      
      **Pipeline:** {{ mr_feedback.pipeline }}
      
      {% endif %}
      {% if jira_updates and jira_updates.has_updates %}
      
      ### ðŸ“‹ Recent Jira Updates
      
      **Status:** {{ jira_updates.status }}
      
      {% for comment in jira_updates.recent_comments[-2:] %}
      - {{ comment.author if comment.author else 'Someone' }}: {{ comment.body[:100] if comment.body else comment }}...
      {% endfor %}
      
      {% endif %}
      {% if (mr_feedback and mr_feedback.has_feedback) or (jira_updates and jira_updates.has_updates) %}
      
      ---
      
      ### ðŸ¤” What would you like to do?
      
      1. **Address MR feedback** - I can help review the comments and suggest fixes
      2. **Check full MR details** - `gitlab_mr_view`
      3. **View full Jira context** - `jira_view_issue`
      4. **Continue coding** - Just start working
      
      {% else %}
      
      âœ… No pending feedback - you're good to continue!
      
      **What would you like to do next?**
      
      {% endif %}
      {% else %}
      
      âœ¨ *Created new branch*
      
      ### Next Steps
      1. Make your changes
      2. Commit: `git commit -m "{{ inputs.issue_key }} - feat: description"`
      3. When ready: `skill_run("create_mr", '{"issue_key": "{{ inputs.issue_key }}", "repo": "{{ resolved_repo.path }}"}')`
      
      {% endif %}
  
  - name: context
    value:
      issue: "{{ issue }}"
      branch: "{{ final_branch }}"
      repo: "{{ resolved_repo.path }}"
      repo_source: "{{ resolved_repo.source }}"
      was_existing: "{{ branch_check.exists }}"
      has_mr: "{{ existing_mr is not none }}"
      has_feedback: "{{ mr_feedback.has_feedback if mr_feedback else false }}"
      mr_id: "{{ mr_feedback.mr_id if mr_feedback else none }}"
